{"posts":[{"title":"beego框架学习","text":"demo","link":"/2021/09/18/%E5%AD%A6%E4%B9%A0/%E5%90%8E%E7%AB%AF/golang/beego/"},{"title":"go语法学习","text":"demo","link":"/2021/09/18/%E5%AD%A6%E4%B9%A0/%E5%90%8E%E7%AB%AF/golang/go/"},{"title":"docker学习","text":"相关文档菜鸟教程官网 vue3部署 先执行npm run build打包 创建一个Dockerfile文件，写入docker相关配置 通过Dockerfile生成container mysql部署参考菜鸟教程，记得创建对应数据库 docker-mysql beego部署 先执行bee pack -be GOOS=linux 创建一个Dockerfile文件，写入docker相关配置 与mysql关联，通过network创建一个公用网络 通过Dockerfile生成同个network下的container 容器连接连接mysql和golangdocker network create -d bridge 网络名称网络名称对应docker-compose.yml里面的network_mode Docker ComposeCompose 是用于定义和运行多容器 Docker 应用程序的工具。 docker compose","link":"/2021/12/15/%E5%AD%A6%E4%B9%A0/%E5%90%8E%E7%AB%AF/docker/study/"},{"title":"jenkins构建golang及mysql","text":"简介这是一个简单的通过jenkins构建golang接口的教程，前提是在安装完jenkins及docker后。 项目地址 项目我是通过beego生成的golang项目，在根目录下新建一个docker-compose.yml文件，其中相关的含义可以查看教程。 主要看golang中的command命令，使用到了wait-for-it这个sh，主要是等待mysql容器完全建立完成，才去执行beego_test这个go可执行文件。 还有就是docker是相对路径执行，context是定义相对的路径，之后dockerfile中的路径可以通用相对路径来判断。 docker-compose.yml 1234567891011121314151617181920212223version: '2'services: golang: build: context: . dockerfile: ./docker/go/Dockerfile container_name: &quot;beego_test&quot; ports: - &quot;8080:8080&quot; network_mode: &quot;test-net&quot; depends_on: - mysql restart: on-failure command: [&quot;./wait-for-it&quot;, &quot;-t&quot;, &quot;30&quot;, &quot;mysql:3307&quot;, &quot;--&quot;, &quot;./beego_test&quot;] mysql: build: ./docker/mysql container_name: &quot;mydb_test&quot; network_mode: &quot;test-net&quot; environment: MYSQL_ROOT_PASSWORD: 123456 #你的root密码 MYSQL_ROOT_HOST: &quot;%&quot; ports: - &quot;3307:3306&quot; 在根目录新建一个文件夹为docker，里面放入dockerfile及wait-for-it等相关文件，搭配上面的docker-compose.yml使用。 /docker/go/Dockerfile 1234567891011121314151617181920212223242526272829FROM golang:latest#定义基础路径ENV GO_PATH /go/src/go_test#创建工作目录RUN mkdir -p $GO_PATH #进入工作目录WORKDIR $GO_PATH #安装netcat wait-for依赖nc命令RUN sed -i s@/deb.debian.org/@/mirrors.aliyun.com/@g /etc/apt/sources.listRUN apt-get -q updateRUN apt-get -qy install netcat#将当前目录下的所有文件复制到指定位置COPY . $GO_PATH# #复制等待shCOPY ./docker/sh/wait-for-it $GO_PATH#给予等待sh权限RUN chmod 777 ./wait-for-it#给予build之后的可执行文件权限RUN chmod 777 ./beego_test#端口EXPOSE 8080 /docker/mysql/Dockerfile 1234567891011121314#基础镜像使用 mysql:latestFROM mysql:latest#定义会被容器自动执行的目录ENV AUTO_RUN_DIR /docker-entrypoint-initdb.d #定义初始化sql文件ENV INSTALL_DB_SQL init_database.sql #把要执行的sql文件放到/docker-entrypoint-initdb.d/目录下，容器会自动执行这个sqlCOPY ./$INSTALL_DB_SQL $AUTO_RUN_DIR/ #给执行文件增加可执行权限RUN chmod a+x $AUTO_RUN_DIR/$INSTALL_DB_SQL /docker/mysql/init_database.sql 123-- 创建数据库drop database if exists go_test;create database go_test; /docker/sh/wait-for-it 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#!/usr/bin/env bash# Use this script to test if a given TCP host/port are availableWAITFORIT_cmdname=${0##*/}echoerr() { if [[ $WAITFORIT_QUIET -ne 1 ]]; then echo &quot;$@&quot; 1&gt;&amp;2; fi }usage(){ cat &lt;&lt; USAGE &gt;&amp;2Usage: $WAITFORIT_cmdname host:port [-s] [-t timeout] [-- command args] -h HOST | --host=HOST Host or IP under test -p PORT | --port=PORT TCP port under test Alternatively, you specify the host and port as host:port -s | --strict Only execute subcommand if the test succeeds -q | --quiet Don't output any status messages -t TIMEOUT | --timeout=TIMEOUT Timeout in seconds, zero for no timeout -- COMMAND ARGS Execute command with args after the test finishesUSAGE exit 1}wait_for(){ if [[ $WAITFORIT_TIMEOUT -gt 0 ]]; then echoerr &quot;$WAITFORIT_cmdname: waiting $WAITFORIT_TIMEOUT seconds for $WAITFORIT_HOST:$WAITFORIT_PORT&quot; else echoerr &quot;$WAITFORIT_cmdname: waiting for $WAITFORIT_HOST:$WAITFORIT_PORT without a timeout&quot; fi WAITFORIT_start_ts=$(date +%s) while : do if [[ $WAITFORIT_ISBUSY -eq 1 ]]; then nc -z $WAITFORIT_HOST $WAITFORIT_PORT WAITFORIT_result=$? else (echo -n &gt; /dev/tcp/$WAITFORIT_HOST/$WAITFORIT_PORT) &gt;/dev/null 2&gt;&amp;1 WAITFORIT_result=$? fi if [[ $WAITFORIT_result -eq 0 ]]; then WAITFORIT_end_ts=$(date +%s) echoerr &quot;$WAITFORIT_cmdname: $WAITFORIT_HOST:$WAITFORIT_PORT is available after $((WAITFORIT_end_ts - WAITFORIT_start_ts)) seconds&quot; break fi sleep 1 done return $WAITFORIT_result}wait_for_wrapper(){ # In order to support SIGINT during timeout: http://unix.stackexchange.com/a/57692 if [[ $WAITFORIT_QUIET -eq 1 ]]; then timeout $WAITFORIT_BUSYTIMEFLAG $WAITFORIT_TIMEOUT $0 --quiet --child --host=$WAITFORIT_HOST --port=$WAITFORIT_PORT --timeout=$WAITFORIT_TIMEOUT &amp; else timeout $WAITFORIT_BUSYTIMEFLAG $WAITFORIT_TIMEOUT $0 --child --host=$WAITFORIT_HOST --port=$WAITFORIT_PORT --timeout=$WAITFORIT_TIMEOUT &amp; fi WAITFORIT_PID=$! trap &quot;kill -INT -$WAITFORIT_PID&quot; INT wait $WAITFORIT_PID WAITFORIT_RESULT=$? if [[ $WAITFORIT_RESULT -ne 0 ]]; then echoerr &quot;$WAITFORIT_cmdname: timeout occurred after waiting $WAITFORIT_TIMEOUT seconds for $WAITFORIT_HOST:$WAITFORIT_PORT&quot; fi return $WAITFORIT_RESULT}# process argumentswhile [[ $# -gt 0 ]]do case &quot;$1&quot; in *:* ) WAITFORIT_hostport=(${1//:/ }) WAITFORIT_HOST=${WAITFORIT_hostport[0]} WAITFORIT_PORT=${WAITFORIT_hostport[1]} shift 1 ;; --child) WAITFORIT_CHILD=1 shift 1 ;; -q | --quiet) WAITFORIT_QUIET=1 shift 1 ;; -s | --strict) WAITFORIT_STRICT=1 shift 1 ;; -h) WAITFORIT_HOST=&quot;$2&quot; if [[ $WAITFORIT_HOST == &quot;&quot; ]]; then break; fi shift 2 ;; --host=*) WAITFORIT_HOST=&quot;${1#*=}&quot; shift 1 ;; -p) WAITFORIT_PORT=&quot;$2&quot; if [[ $WAITFORIT_PORT == &quot;&quot; ]]; then break; fi shift 2 ;; --port=*) WAITFORIT_PORT=&quot;${1#*=}&quot; shift 1 ;; -t) WAITFORIT_TIMEOUT=&quot;$2&quot; if [[ $WAITFORIT_TIMEOUT == &quot;&quot; ]]; then break; fi shift 2 ;; --timeout=*) WAITFORIT_TIMEOUT=&quot;${1#*=}&quot; shift 1 ;; --) shift WAITFORIT_CLI=(&quot;$@&quot;) break ;; --help) usage ;; *) echoerr &quot;Unknown argument: $1&quot; usage ;; esacdoneif [[ &quot;$WAITFORIT_HOST&quot; == &quot;&quot; || &quot;$WAITFORIT_PORT&quot; == &quot;&quot; ]]; then echoerr &quot;Error: you need to provide a host and port to test.&quot; usagefiWAITFORIT_TIMEOUT=${WAITFORIT_TIMEOUT:-15}WAITFORIT_STRICT=${WAITFORIT_STRICT:-0}WAITFORIT_CHILD=${WAITFORIT_CHILD:-0}WAITFORIT_QUIET=${WAITFORIT_QUIET:-0}# Check to see if timeout is from busybox?WAITFORIT_TIMEOUT_PATH=$(type -p timeout)WAITFORIT_TIMEOUT_PATH=$(realpath $WAITFORIT_TIMEOUT_PATH 2&gt;/dev/null || readlink -f $WAITFORIT_TIMEOUT_PATH)WAITFORIT_BUSYTIMEFLAG=&quot;&quot;if [[ $WAITFORIT_TIMEOUT_PATH =~ &quot;busybox&quot; ]]; then WAITFORIT_ISBUSY=1 # Check if busybox timeout uses -t flag # (recent Alpine versions don't support -t anymore) if timeout &amp;&gt;/dev/stdout | grep -q -e '-t '; then WAITFORIT_BUSYTIMEFLAG=&quot;-t&quot; fielse WAITFORIT_ISBUSY=0fiif [[ $WAITFORIT_CHILD -gt 0 ]]; then wait_for WAITFORIT_RESULT=$? exit $WAITFORIT_RESULTelse if [[ $WAITFORIT_TIMEOUT -gt 0 ]]; then wait_for_wrapper WAITFORIT_RESULT=$? else wait_for WAITFORIT_RESULT=$? fifiif [[ $WAITFORIT_CLI != &quot;&quot; ]]; then if [[ $WAITFORIT_RESULT -ne 0 &amp;&amp; $WAITFORIT_STRICT -eq 1 ]]; then echoerr &quot;$WAITFORIT_cmdname: strict mode, refusing to execute subprocess&quot; exit $WAITFORIT_RESULT fi exec &quot;${WAITFORIT_CLI[@]}&quot;else exit $WAITFORIT_RESULTfi 值得注意的是，在mysql的dockerfile中定义了自动执行sql文件，创建数据库。 jenkins在jenkins中需要先添加go插件，可以在插件管理中下载并重启jenkins。然后就是对其进行配置，进入全局工具配置里面添加golang相关配置，主要是安装目录的设置，因为golang官网速度很慢，不一定能拉下来，所以可以在本地先安装好golang，配置好环境，然后设置下安装目录即可。 golang安装golang的安装可以先在官网下载，然后通过rz上传到服务器上，接下来通过解压即可 1tar -C /usr/local -xzf go1.12.5.linux-amd64.tar.gz 环境变量则是简单的设置添加到path中 1export PATH=$PATH:/usr/local/go/bin // 添加go/bin到系统环境变量PATH中 然后验证go version即可。 新增任务接下来就是新建一个自由风格的任务。 主要是在构建环境那块勾选Add timestamps to the Console Output及Set up Go programming language tools（并选则go版本）。 然后就是执行shell， 1234567891011121314#设置代理，go get获取依赖速度会快些export GO111MODULE=onexport GOPROXY=https://goproxy.cngo get#打包一个go可执行文件名为beego_testgo build -o beego_test#删除相关容器及镜像[ ! &quot;$(docker network ls | grep test-net)&quot; ] &amp;&amp; docker network create -d bridge test-net[ &quot;$(docker ps -a | grep beego_test)&quot; ] &amp;&amp; docker rm -f beego_test[ &quot;$(docker ps -a | grep mydb_test)&quot; ] &amp;&amp; docker rm -f mydb_test[ &quot;$(docker image ls | grep beego_test_mysql)&quot; ] &amp;&amp; docker rmi -f beego_test_mysql[ &quot;$(docker image ls | grep beego_test_golang)&quot; ] &amp;&amp; docker rmi -f beego_test_golang#执行docker-composedocker-compose up -d 总结以上的构建并部署golang项目比较简单，相关操作也是按部就班来，还有很多细化的操作如手动编写shell脚本来控制容器等目前暂未学习。","link":"/2022/04/29/%E5%AD%A6%E4%B9%A0/%E5%90%8E%E7%AB%AF/jenkins/%E6%9E%84%E5%BB%BAgolang%E5%8F%8Amysql/"},{"title":"jenkins安装","text":"参考地址 安装jdk1yum install -y java-1.8.0-openjdk-devel.x86_64 检查是否安装成功，java -version 安装jenkinsyum的repo中默认没有Jenkins，需要先将Jenkins存储库添加到yum repos直接上命令，等待安装即可 1234wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key#jenkins 默认安装最新的yum install jenkins -y 启动jenkins1service jenkins start 自动安装的话，默认端口为8080，默认目录： 安装目录：/var/lib/jenkins 日志目录：/var/log/jenkins/jenkins.log 默认配置目录：/etc/sysconfig/jenkins 可修改jenkins用户为root用户、修改端口等 12vim /etc/sysconfig/jenkinsservice jenkins restart 其中的JENKINS_USER和JENKINS_PORT为用户和端口 如果端口修改没有生效，可以使用如下方法： 123456789# 进入目录cd /usr/lib/systemd/systemvim jenkins.service# 或者vim /usr/lib/systemd/system/jenkins.service# 修改为想要的端口Environment=&quot;JENKINS_PORT=9080&quot;# 重新加载配置文件systemctl daemon-reload 激活jenkins首次登陆jenkins（http://http://175.178.107.242:9080/），需要输入密码 在服务器中输入以下命令，找到默认密码 1cat /var/lib/jenkins/secrets/initialAdminPassword 然后注册用户，可以选择admin，之后选择推荐插件安装就好了 设置git由于默认的用户是jenkins，所以生成ssh key要在Jenkins用户的目录下 12345678su rootcd /var/lib/jenkins/.sshssh-keygen -t rsa -C your-email@sample.com# 注意下一步提示保存位置的时候，要再输入/var/lib/jenkins/.ssh/id_rsa# Enter file in which to save the key (/root/.ssh/id_rsa): /var/lib/jenkins/.ssh/id_rsachown jenkins:jenkins id_rsa id_rsa.pubcat id_rsa.pub 将id_rsa.pub（公钥）的内容放到github上的sshkey里，然后将id_rsa（密钥）添加到jenkins的Credentials里，这样jenkins才能访问git","link":"/2022/04/25/%E5%AD%A6%E4%B9%A0/%E5%90%8E%E7%AB%AF/jenkins/%E5%AE%89%E8%A3%85/"},{"title":"jenkins构建react项目","text":"node插件 首先需要在Jenkins里安装node插件，然后配置，在系统管理里面的插件管理搜索node，然后安装并重启 然后进行配置 新建一个任务，选择第一项，自由风格，然后在构建环境栏中进行node配置 任务配置在新建的任务中进行相关配置。 可以填写github的地址 源码管理，这里填入的是github的clone地址（ssh），然后配置上密钥和项目分支。 最后则是编写构建栏的代码，可以选择执行shell，并输入以下命令。 1234567npm install --registry=https://registry.npm.taobao.org #使用淘宝镜像export CI=false #防止CI报错npm run build #执行打包命令docker build -t nginx/react:v1.1.0 . #根据dockerfile生成镜像[ &quot;$(docker ps | grep three-shopping-mall)&quot; ] &amp;&amp; docker kill -s KILL three-shopping-mall #如果容器处于运行状态则清除[ &quot;$(docker ps -a | grep three-shopping-mall)&quot; ] &amp;&amp; docker rm three-shopping-mall #如果容器存在则移除docker run -d -p 8030:80 --name three-shopping-mall nginx/react:v1.1.0 #生成容器 由于服务器内存太小，需要对内存进行swap，不然构建经常会崩溃。 12345678910111213#操作命令：#查看：free -h#创建（可以和内存1：1,内存1g可以用1024）：dd if=/dev/zero of=/data/swapfile bs=1M count=1024 #设置交换文件；mkswap /data/swapfile#启用：swapon /data/swapfile#设置开机自动挂载vim /etc/fstab#然后在最后一行输入/data/swapfile swap swap defaults 0 0 其他命令 1234#停用swapoff /data/swapfile#删除rm /data/swapfile -rf 项目相关配置由于使用到docker，需要在项目下创建Dockerfile如下： 1234FROM nginxMAINTAINER zhbCOPY build /usr/share/nginx/html/ COPY config/nginx /etc/nginx/conf.d/ 这里对打包后的文件进行拷贝到对应目录，还有就是将nginx配置也拷贝过去。 1234567891011server { listen 80; listen [::]:80; server_name localhost; #access_log /var/log/nginx/host.access.log main; location / { root /usr/share/nginx/html; index index.html index.htm; try_files $uri $uri/ /index.html; }}","link":"/2022/04/25/%E5%AD%A6%E4%B9%A0/%E5%90%8E%E7%AB%AF/jenkins/%E6%9E%84%E5%BB%BAreact/"},{"title":"nginx解决跨域问题","text":"一. 产生跨域的原因1.浏览器限制2.跨域3.XHR（XMLHttpRequest）请求 二. 解决思路解决跨域有多重，在这里主要讲用nginx解决跨域 1.JSONP2.nginx代理3.浏览器禁止检查跨域三. 下载安装nginxnginx下载地址 选择其中一个版本下载，再解压即可使用 在nginx目录下输入nginx -v，若出现版本号，则安装成功 四. nginx反向代理解决跨域（客户端解决跨域）1.我们使用jquery的ajax发送请求，node开启后台服务前端代码：利用jQuery的ajax api发送请求 12345678910111213141516171819202122232425262728&lt;button id=&quot;getOK&quot;&gt;发送请求OK(客户端解决跨域问题)&lt;/button&gt; &lt;button id=&quot;getNO&quot;&gt;发送请求NO(客户端解决跨域问题)&lt;/button&gt; &lt;script&gt; $(document).ready(function () { $('#getOK').click(function () { $.ajax({ url:'http://localhost:3000/ok', success:function(res) { console.log(&quot;success&quot;,res) }, error:function(err) { console.log('fail',err) } }) }) $('#getNO').click(function () { $.ajax({ url:'http://localhost:3000/no', success:function(res) { console.log(&quot;success&quot;,res) }, error:function(err) { console.log('fail',err) } }) }) }) &lt;/script&gt; 后端代码：利用node的express框架开启服务，并根据url返回json格式的数据,设置这么多接口的目的是为了后面匹配nginx的location配置的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const express = require('express')const cookieParser = require('cookie-parser')var app = express()var router = express.Router()router.get('/ok',function (req,res) { res.json({ code:200, msg:&quot;isOK&quot; }) })router.get('/ok/son',function (req,res) { res.json({ code:200, msg:&quot;isOKSon&quot; }) })router.get('/ok2',function (req,res) { res.json({ code:200, msg:&quot;isOK2&quot; }) })router.get('/no',function (req,res) { res.json({ code:200, msg:&quot;isNO&quot; }) })router.get('/no/son',function (req,res) { res.json({ code:200, msg:&quot;isNOSON&quot; }) })router.get('/no/son2',function (req,res) { res.json({ code:200, msg:&quot;isNOSON2&quot; }) })app.use(router)app.use(cookieParser)app.listen(3000,function () { console.log('listen in 3000')}) 然后开启node服务 node app.js 现在可以测试下接口 可以看出，node服务成功开启现在可以尝试不开启nginx服务直接发送ajax请求会出现什么情况（注意：发送ajax请求需要以服务器方式打开网页，不能以文件形式） 如图，在5500端口请求3000端口出现了跨域问题，这时候就可以开启nginx服务并配置location进行解决 2.配置nginx进行反向代理解决跨域反向代理的原理就是讲前端的地址和后端的地址用nginx转发到同一个地址下，如5500端口和3000端口都转到3003端口下，具体配置如下： 打开nginx目录下的conf目录里面nginx.conf 为了方便以后测试，我们将配置分离开来，弄成多个文件 在nginx.conf的http对象的最后加上include …/vhost/test.conf;（注意要最后加上分号） 这样就可以在test.conf下单独配置了具体的location配置规则如下：nginx的location配置规则 1234567891011121314151617181920#客户端设置跨域（反向代理）后端{ listen 3003; 后端_name localhost; ## = /表示精确匹配路径为/的url，真实访问为http://localhost:5500 location = / { proxy_pass http://localhost:5500; } ## /no 表示以/no开头的url，包括/no1,no/son，或者no/son/grandson ## 真实访问为http://localhost:5500/no开头的url ## 若 proxy_pass最后为/ 如http://localhost:3000/;匹配/no/son，则真实匹配为http://localhost:3000/son location /no { proxy_pass http://localhost:3000; } ## /ok/表示精确匹配以ok开头的url，/ok2是匹配不到的，/ok/son则可以 location /ok/ { proxy_pass http://localhost:3000; }} 上面代码的意思是将localhost:3003转发为location:5500,也就是说现在访问localhost:3003实际上是访问location:5500,而访问localhost:3003/no则是访问localhost:3000,并以no开头的url 现在我们可以开启nginx服务了，在nginx目录下使用start nginx即可开启服务 每次修改配置都需要执行nginx -s reload命令才能生效 现在修改前端代码，将之前请求的接口的端口换为3003，如下： 1234567891011$('#getOK').click(function () { $.ajax({ url:'http://localhost:3003/ok', success:function(res) { console.log(&quot;success&quot;,res) }, error:function(err) { console.log('fail',err) } }) }) 在浏览器访问的也不算location:5500,而是localhost:3003了，再次发送请求也不会出现跨域问题了，因为他们都是同一个域了，这就是nginx反向代理 五. 后端配置nginx解决跨域（服务端解决跨域）1. 依旧是ajax＋node这是前端代码 1234567891011121314151617$(document).ready(function () { $('#get').click(function () { $.ajax({ url:'http://localhost:3002/ok', // 带cookies的请求 xhrFields:{ withCredentials:true }, success:function(res) { console.log(&quot;success&quot;,res) }, error:function(err) { console.log('fail',err) } }) }) }) 后端代码同前面还有nginx配置如下： 1234567891011121314151617181920212223242526272829303132#服务端设置跨域后端{ listen 3002; 后端_name localhost; location /ok { proxy_pass http://localhost:3000; # 指定允许跨域的方法，*代表所有 add_header Access-Control-Allow-Methods *; # 预检命令的缓存，如果不缓存每次会发送两次请求 add_header Access-Control-Max-Age 3600; # 带cookie请求需要加上这个字段，并设置为true add_header Access-Control-Allow-Credentials true; # 表示允许这个域跨域调用（客户端发送请求的域名和端口） # $http_origin动态获取请求客户端请求的域 不用*的原因是带cookie的请求不支持*号 add_header Access-Control-Allow-Origin $http_origin; # 表示请求头的字段 动态获取 add_header Access-Control-Allow-Headers $http_access_control_request_headers; # OPTIONS预检命令，预检命令通过时才发送请求 # 检查请求的类型是不是预检命令 if ($request_method = OPTIONS){ return 200; } }} 发送预检命令的是非简单请求，具体可以看慕课网ajax跨域完全讲解实际上不是非简单请求的且不带cookie只需2个字段即可解决跨域add_header Access-Control-Allow-Methods *;add_header Access-Control-Allow-Origin $http_origin; 具体效果如下图： 这时只需改ajax请求的端口接口，无需修改前端服务器的地址 最后附上源码：nginx解决跨域问题","link":"/2019/05/13/%E5%AD%A6%E4%B9%A0/%E5%90%8E%E7%AB%AF/nginx/%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"},{"title":"flutter学习","text":"一个简单的app简单的flutter应用","link":"/2021/07/21/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/flutter/flutter/"},{"title":"dart学习","text":"相关学习放在github中dart语法学习","link":"/2021/06/04/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/flutter/dart/"},{"title":"流程图绘制库","text":"这个库可以绘制流程图及流动连线的效果。 效果可看演示demo：演示demo 也可以参考源码：demo源码 库源码 传参解析该类传入一个对象，该对象有以下几个字段，其中imgData，canvas，flowCanvas，ctx，flowCtx必填，其他都可选。 其中注意需要2个canvas和context实例，主canvas为绘制图标、标题、线段的容器，流动效果canvas则是流动动画效果的容器。 123456789public imgData //图片列表public lineData //线段列表public fps //频率public stepSize //移动步数public flowLength //流动箭头长度public canvas //主canvaspublic flowCanvas //流动效果canvaspublic ctx //主canvas contextpublic flowCtx //流动效果canvas context 其中imgData数组的数据格式如下： 1234567891011121314151617181920212223interface Coordinate { x: number //坐标x y: number //坐标y}interface TextOption { text?: string //文案 show?: boolean //是否显示 style?: { //样式 fontWeight?: string //字体浓淡 position?: string //字体位置 color?: string //字体颜色 fontFamily?: string //字体风格 fontSize?: number //字体东西 imgTextSplit?: number //图片和文案间隔 }}interface ImgObj extends Coordinate { imgUrl: string //图片url width: number //图片宽度 height: number //图片高度 textOption?: TextOption //文案选项}let imgData: Array&lt;ImgObj&gt;; lineData数组的数据格式如下，其中只要注意points，arrowDirection，lineOption这几个字段即可： 1234567891011121314151617181920212223242526272829303132333435363738394041//线段选项interface LineOption { lineWidth?: number //线段宽度 arrowSize?: number //箭头大小 arrowRoundSize?: number //箭头圆角大小 color?: string //颜色 lineCap?: string //箭头样式 lineJoin?: string //箭头连接处样式 lineImgSplit?: number //图片和线段的连接间隔}interface SplitLine { angle?: number length?: number originLength?: number paths?: Array&lt;PathsItem&gt; endLines?: Array&lt;SplitLine&gt; startLines?: Array&lt;SplitLine&gt; fromPixel?: Coordinate toPixel?: Coordinate}//线段对象interface LineObj { points: Array&lt;Coordinate&gt; //点坐标数组 arrowDirection: string //箭头方向 lineOption?: LineOption //线段选项 paths?: Array&lt;PathsItem&gt; //路径数组 lineSpace?: number //线段间隔 flowOption?: FlowOption //流动效果选项 originLength?: number //原始长度 splitLines?: Array&lt;SplitLine&gt; //线段数据}let lineData: Array&lt;LineObj&gt; = [{ points: [{ x: 260, y: 225 }, { x: 390, y: 225 }], arrowDirection: 'right'}]; 生成的实例有两个方法draw和clear，draw即开始绘制canvas，clear则是清除canvas及相关动画。 使用js部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import CreateImgLineFlow from 'flow-chart-canvas';let canvas: HTMLCanvasElement = document.querySelector('#canvas');let flowCanvas: HTMLCanvasElement = document.querySelector('#flowCanvas');let { clientHeight, clientWidth } = canvas;let { clientHeight: flowClientHeight, clientWidth: flowClientWidth } = canvas;canvas.width = clientWidth;canvas.height = clientHeight;flowCanvas.width = flowClientWidth;flowCanvas.height = flowClientHeight;let ctx: any = canvas.getContext('2d');let flowCtx: any = flowCanvas.getContext('2d');ctx.clearRect(0, 0, 500, 500);flowCtx.clearRect(0, 0, 500, 500);let imgData = [{ imgUrl: 'https://img0.baidu.com/it/u=151392495,873552640&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500', textOption: { text: '测试1', show: true, style: { fontWeight: '600', position: 'bottom', } }, x: 200, y: 200, width: 50, height: 50}, { imgUrl: 'https://img0.baidu.com/it/u=151392495,873552640&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500', textOption: { text: '测试1', show: true, style: { fontWeight: '600', position: 'bottom', } }, x: 400, y: 200, width: 50, height: 50}]let lineData = [{ points: [{ x: 260, y: 225 }, { x: 390, y: 225 }], arrowDirection: 'right'}]let createImgLineFlow = new CreateImgLineFlow({ lineData, imgData, canvas, flowCanvas, ctx, flowCtx})createImgLineFlow.draw(); html及css部分 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; } #flowCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;canvas id=&quot;flowCanvas&quot;&gt;&lt;/canvas&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2023/02/10/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/canvas/%E6%B5%81%E7%A8%8B%E5%9B%BE/"},{"title":"hexo修改npm包","text":"头像在包hexo-theme-icarus中找到source/img文件夹，在其中添加头像author.png。 修改背景图 在包hexo-theme-icarus中找到source/img文件夹，在其中添加背景图。 然后在source/css/style.styl文件中添加自定义，并新建文件。 1234567891011121314151617181920//style.styl@import 'custom'//custom.stylbody::before { content: ''; position: fixed; z-index: -1; top: 0; right: 0; bottom: 0; left: 0; opacity: .01; transition: opacity 1s; background-image: url('../img/bg.png'); background-position: center center; background-size: cover;}body.ready::before { opacity: 1;} 最后在source/js/main.js文件中添加代码 12345window.onload = () =&gt; { setTimeout(() =&gt; { document.querySelector('body').classList.add('ready') }, 1000);} 底部左侧备案在layout/common/footer.jsx文件修改代码 1234567891011121314&lt;div class=&quot;level-start&quot;&gt; {/* &lt;a class=&quot;footer-logo is-block mb-2&quot; href={siteUrl}&gt; {footerLogo} &lt;/a&gt; */} &lt;p class=&quot;is-size-7&quot;&gt; 备案/许可证编号为：&lt;a href=&quot;https://beian.miit.gov.cn/&quot;&gt;粤ICP备2022018683号-1&lt;/a&gt; {/* &lt;span dangerouslySetInnerHTML={{ __html: `&amp;copy; ${siteYear} ${author || siteTitle}` }}&gt;&lt;/span&gt; &amp;nbsp;&amp;nbsp;Powered by &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;&amp;nbsp;&amp;&amp;nbsp; &lt;a href=&quot;https://github.com/ppoffice/hexo-theme-icarus&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Icarus&lt;/a&gt; {showVisitorCounter ? &lt;br /&gt; : null} {showVisitorCounter ? &lt;span id=&quot;busuanzi_container_site_uv&quot; dangerouslySetInnerHTML={{ __html: visitorCounterTitle }}&gt;&lt;/span&gt; : null} */} &lt;/p&gt; &lt;/div&gt; 修改布局在include/style/base.styl中修改 1$fullhd ?= 1660px 在自定义custom中加入 123456.column-main width: 56% !important;.column-left width: 22% !important;.column-right width: 22% !important; 鼠标特效 在source/js/main.js中插入 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/**网页鼠标点击特效（爱心）**/ ! function (e, t, a) { function r() { for (var e = 0; e &lt; s.length; e++) s[e].alpha &lt;= 0 ? (t.body.removeChild(s[e].el), s.splice(e, 1)) : (s[ e].y--, s[e].scale += .004, s[e].alpha -= .013, s[e].el.style.cssText = &quot;left:&quot; + s[e].x + &quot;px;top:&quot; + s[e].y + &quot;px;opacity:&quot; + s[e].alpha + &quot;;transform:scale(&quot; + s[e].scale + &quot;,&quot; + s[e] .scale + &quot;) rotate(45deg);background:&quot; + s[e].color + &quot;;z-index:99999&quot;); requestAnimationFrame(r) } function n() { var t = &quot;function&quot; == typeof e.onclick &amp;&amp; e.onclick; e.onclick = function (e) { t &amp;&amp; t(), o(e) } } function o(e) { var a = t.createElement(&quot;div&quot;); a.className = &quot;heart&quot;, s.push({ el: a, x: e.clientX - 5, y: e.clientY - 5, scale: 1, alpha: 1, color: c() }), t.body.appendChild(a) } function i(e) { var a = t.createElement(&quot;style&quot;); a.type = &quot;text/css&quot;; try { a.appendChild(t.createTextNode(e)) } catch (t) { a.styleSheet.cssText = e } t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a) } function c() { return &quot;rgb(&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math .random()) + &quot;)&quot; } var s = []; e.requestAnimationFrame = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e .mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) { setTimeout(e, 1e3 / 60) }, i( &quot;.heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}&quot; ), n(), r() }(window, document); /**鼠标移动特效 */ !function () { function n(n, e, t) { return n.getAttribute(e) || t } function e(n) { return document.getElementsByTagName(n) } function t() { var t = e(&quot;script&quot;), o = t.length, i = t[o - 1]; return {l: o, z: n(i, &quot;zIndex&quot;, 9999), o: n(i, &quot;opacity&quot;, .5), c: n(i, &quot;color&quot;, &quot;0,0,0&quot;), n: n(i, &quot;count&quot;, 99)} } function o() { a = m.width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth, c = m.height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight } function i() { r.clearRect(0, 0, a, c); var n, e, t, o, m, l; s.forEach(function (i, x) { for (i.x += i.xa, i.y += i.ya, i.xa *= i.x &gt; a || i.x &lt; 0 ? -1 : 1, i.ya *= i.y &gt; c || i.y &lt; 0 ? -1 : 1, r.fillRect(i.x - .5, i.y - .5, 1, 1), e = x + 1; e &lt; u.length; e++) n = u[e], null !== n.x &amp;&amp; null !== n.y &amp;&amp; (o = i.x - n.x, m = i.y - n.y, l = o * o + m * m, l &lt; n.max &amp;&amp; (n === y &amp;&amp; l &gt;= n.max / 2 &amp;&amp; (i.x -= .03 * o, i.y -= .03 * m), t = (n.max - l) / n.max, r.beginPath(), r.lineWidth = t / 2, r.strokeStyle = &quot;rgba(&quot; + d.c + &quot;,&quot; + (t + .2) + &quot;)&quot;, r.moveTo(i.x, i.y), r.lineTo(n.x, n.y), r.stroke())) }), x(i) } var a, c, u, m = document.createElement(&quot;canvas&quot;), d = t(), l = &quot;c_n&quot; + d.l, r = m.getContext(&quot;2d&quot;), x = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (n) { window.setTimeout(n, 1e3 / 45) }, w = Math.random, y = {x: null, y: null, max: 2e4}; m.id = l, m.style.cssText = &quot;position:fixed;top:0;left:0;z-index:&quot; + d.z + &quot;;opacity:&quot; + d.o, e(&quot;body&quot;)[0].appendChild(m), o(), window.onresize = o, window.onmousemove = function (n) { n = n || window.event, y.x = n.clientX, y.y = n.clientY }, window.onmouseout = function () { y.x = null, y.y = null }; for (var s = [], f = 0; d.n &gt; f; f++) { var h = w() * a, g = w() * c, v = 2 * w() - 1, p = 2 * w() - 1; s.push({x: h, y: g, xa: v, ya: p, max: 6e3}) } u = s.concat([y]), setTimeout(function () { i() }, 100) }(); 其他1234567891011121314151617181920212223242526272829303132333435363738//cusstom.stylbody::before { content: ''; position: fixed; z-index: -1; top: 0; right: 0; bottom: 0; left: 0; opacity: .01; transition: opacity 1s; background-image: url('../img/bg.png'); background-position: center center; background-size: cover;}body.ready::before { opacity: 1;}@media screen and (min-width: 1088px) .is-3-column2 .column top: 5.75rem; .column-main width: 56% !important; margin-top: 3.25rem; .column-left width: 22% !important; margin-top: 3.25rem; .column-right width: 22% !important; margin-top: 3.25rem; .navbar z-index: 100; .navbar-main position: fixed; width: 100%; top: 0;","link":"/2021/05/04/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/hexo/%E4%BF%AE%E6%94%B9%E5%8C%85/"},{"title":"写作","text":"新增文章方法在终端输入以下命令 如文章名称可以为react hooks，路径为”学习/前端/react/react hooks” 1hexo new &quot;文章名称&quot; -p “文章路径” 常用命令启动1npm run start 发布1npm run publish","link":"/2021/01/04/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/hexo/%E5%86%99%E4%BD%9C/"},{"title":"react——Context","text":"由于react的数据是通过 props 属性自上而下（由父及子）进行传递的，但当组件层级过深或者过广时，这样的方式就很繁琐了。 何时使用 Context当组件层级过深或者过广时。如很多不同层级的组件需要访问同样一些的数据。 使用 Context 之前的考虑Context 主要应用场景在于很多不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差。 如果你只是想避免层层传递一些属性，组件组合（component composition）有时候是一个比 context 更好的解决方案。 比如，考虑这样一个 Page 组件，它层层向下传递 user 和 avatarSize 属性，从而深度嵌套的 Link 和 Avatar 组件可以读取到这些属性： 123456789&lt;Page user={user} avatarSize={avatarSize} /&gt;// ... 渲染出 ...&lt;PageLayout user={user} avatarSize={avatarSize} /&gt;// ... 渲染出 ...&lt;NavigationBar user={user} avatarSize={avatarSize} /&gt;// ... 渲染出 ...&lt;Link href={user.permalink}&gt; &lt;Avatar user={user} size={avatarSize} /&gt;&lt;/Link&gt; 如果在最后只有 Avatar 组件真的需要 user 和 avatarSize，那么层层传递这两个 props 就显得非常冗余。而且一旦 Avatar 组件需要更多从来自顶层组件的 props，你还得在中间层级一个一个加上去，这将会变得非常麻烦。 一种无需 context 的解决方案是将 Avatar 组件自身传递下去，因而中间组件无需知道 user 或者 avatarSize 等 props： 如下： 123456789101112131415161718function Page(props) { const user = props.user; const userLink = ( &lt;Link href={user.permalink}&gt; &lt;Avatar user={user} size={props.avatarSize} /&gt; &lt;/Link&gt; ); return &lt;PageLayout userLink={userLink} /&gt;;}// 现在，我们有这样的组件：&lt;Page user={user} avatarSize={avatarSize} /&gt;// ... 渲染出 ...&lt;PageLayout userLink={...} /&gt;// ... 渲染出 ...&lt;NavigationBar userLink={...} /&gt;// ... 渲染出 ...{props.userLink} 这种变化下，只有最顶部的 Page 组件需要知道 Link 和 Avatar 组件是如何使用 user 和 avatarSize 的。 APIReact.createContext1const MyContext = React.createContext(defaultValue); 创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。 只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。这有助于在不使用 Provider 包装组件的情况下对组件进行测试。注意：将 undefined 传递给 Provider 的 value 时，消费组件的 defaultValue 不会生效。 Context.Provider1&lt;MyContext.Provider value={/* 某个值 */}&gt; 每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。 Provider 接收一个 value 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。 当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 shouldComponentUpdate 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。 Class.contextType12345678910111213141516171819class MyClass extends React.Component { componentDidMount() { let value = this.context; /* 在组件挂载完成后，使用 MyContext 组件的值来执行一些有副作用的操作 */ } componentDidUpdate() { let value = this.context; /* ... */ } componentWillUnmount() { let value = this.context; /* ... */ } render() { let value = this.context; /* 基于 MyContext 组件的值进行渲染 */ }}MyClass.contextType = MyContext; 挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。这能让你使用 this.context 来消费最近 Context 上的那个值。你可以在任何生命周期中访问到它，包括 render 函数中。 如果你正在使用实验性的 public class fields 语法，你可以使用 static 这个类属性来初始化你的 contextType。 1234567class MyClass extends React.Component { static contextType = MyContext; render() { let value = this.context; /* 基于这个值进行渲染工作 */ }} Context.Consumer123&lt;MyContext.Consumer&gt; {value =&gt; /* 基于 context 值进行渲染*/}&lt;/MyContext.Consumer&gt; Context.displayNamecontext 对象接受一个名为 displayName 的 property，类型为字符串。React DevTools 使用该字符串来确定 context 要显示的内容。 示例，下述组件在 DevTools 中将显示为 MyDisplayName： 1234const MyContext = React.createContext(/* some value */);MyContext.displayName = 'MyDisplayName';&lt;MyContext.Provider&gt; // &quot;MyDisplayName.Provider&quot; 在 DevTools 中&lt;MyContext.Consumer&gt; // &quot;MyDisplayName.Consumer&quot; 在 DevTools 中","link":"/2021/01/10/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/react/context/"},{"title":"3D物品展示","text":"这是一个由react ，react router，redux，typeScript和three.js搭建的3D物品展示网页。 主要页面 线上地址 源码 首页 详情页 404页","link":"/2022/04/15/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/react/3D%E7%89%A9%E5%93%81%E5%B1%95%E7%A4%BA/"},{"title":"react——Hook","text":"Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。 使用 Hook 其中一个目的就是要解决 class 中生命周期函数经常包含不相关的逻辑，但又把相关逻辑分离到了几个不同方法中的问题。 State Hook声明 State 变量在 class 中，我们通过在构造函数中设置 this.state 为 { count: 0 } 来初始化 count state 为 0： 12345class Example extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; } 在函数组件中，我们没有 this，所以我们不能分配或读取 this.state。我们直接在组件中调用 useState Hook： 12345import React, { useState } from 'react';function Example() { // 声明一个叫 “count” 的 state 变量 const [count, setCount] = useState(0); 我们声明了一个叫 count 的 state 变量，然后把它设为 0。React 会在重复渲染时记住它当前的值，并且提供最新的值给我们的函数。我们可以通过调用 setCount 来更新当前的 count。 读取 State当我们想在 class 中显示当前的 count，我们读取 this.state.count： 1&lt;p&gt;You clicked {this.state.count} times&lt;/p&gt; 在函数中，我们可以直接用 count: 1&lt;p&gt;You clicked {count} times&lt;/p&gt; 更新 State在 class 中，我们需要调用 this.setState() 来更新 count 值： 123&lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt; Click me&lt;/button&gt; 在函数中，我们已经有了 setCount 和 count 变量，所以我们不需要 this: 123&lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me&lt;/button&gt; Effect HookEffect Hook 可以让你在函数组件中执行副作用操作 React 组件中执行过数据获取、订阅或者手动修改过 DOM。我们统一把这些操作称为“副作用”，或者简称为“作用”。 1234567891011121314151617181920import React, { useState, useEffect } from 'react';function Example() { const [count, setCount] = useState(0); // Similar to componentDidMount and componentDidUpdate: useEffect(() =&gt; { // Update the document title using the browser API document.title = `You clicked ${count} times`; }); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; );} 你可以把 useEffect Hook 看做 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合。 在 React 组件中有两种常见副作用操作：需要清除的和不需要清除的。 无需清除的 effect有时候，我们只想在 React 更新 DOM 之后运行一些额外的代码。比如发送网络请求，手动变更 DOM，记录日志，这些都是常见的无需清除的操作。因为我们在执行完这些操作之后，就可以忽略他们了。让我们对比一下使用 class 和 Hook 都是怎么实现这些副作用的。 使用 class 的示例这是一个 React 计数器的 class 组件。它在 React 对 DOM 进行操作之后，立即更新了 document 的 title 属性 1234567891011121314151617181920class Example extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; } componentDidMount() { document.title = `You clicked ${this.state.count} times`; } componentDidUpdate() { document.title = `You clicked ${this.state.count} times`; } render() { return ( &lt;div&gt; &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt; &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt; Click me &lt;/button&gt; &lt;/div&gt; ); }} 注意，在这个 class 中，我们需要在两个生命周期函数中编写重复的代码。 使用 Hook 的示例1234567891011121314import React, { useState, useEffect } from 'react';function Example() { const [count, setCount] = useState(0); useEffect(() =&gt; { document.title = `You clicked ${count} times`; }); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; );} useEffect 默认情况下，在第一次渲染之后和每次更新之后都会执行。 需要清除的 effect之前，我们研究了如何使用不需要清除的副作用，还有一些副作用是需要清除的。例如订阅外部数据源。这种情况下，清除工作是非常重要的，可以防止引起内存泄露！现在让我们来比较一下如何用 Class 和 Hook 来实现。 使用 Class 的示例在 React class 中，你通常会在 componentDidMount 中设置订阅，并在 componentWillUnmount 中清除它。例如，假设我们有一个 ChatAPI 模块，它允许我们订阅好友的在线状态。以下是我们如何使用 class 订阅和显示该状态： 123456789101112131415class FriendStatus extends React.Component { constructor(props) { super(props); this.state = { isOnline: null }; this.handleStatusChange = this.handleStatusChange.bind(this); } componentDidMount() { ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange ); } componentWillUnmount() { ChatAPI.unsubscribeFromFriendStatus( this.props.friend.id, this.handleStatusChange ); } handleStatusChange(status) { this.setState({ isOnline: status.isOnline }); } render() { if (this.state.isOnline === null) { return 'Loading...'; } return this.state.isOnline ? 'Online' : 'Offline'; }} 你会注意到 componentDidMount 和 componentWillUnmount 之间相互对应。使用生命周期函数迫使我们拆分这些逻辑代码，即使这两部分代码都作用于相同的副作用。 使用 Hook 的示例如果你的 effect 返回一个函数，React 将会在执行清除操作时调用它： 12345678910111213141516171819import React, { useState, useEffect } from 'react';function FriendStatus(props) { const [isOnline, setIsOnline] = useState(null); useEffect(() =&gt; { function handleStatusChange(status) { setIsOnline(status.isOnline); } ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); // Specify how to clean up after this effect: return function cleanup() { ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); }; }); if (isOnline === null) { return 'Loading...'; } return isOnline ? 'Online' : 'Offline';} 为什么要在 effect 中返回一个函数？ 这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。 React 何时清除 effect？ React 会在组件卸载的时候执行清除操作。 通过跳过 Effect 进行性能优化在某些情况下，每次渲染后都执行清理或者执行 effect 可能会导致性能问题。在 class 组件中，我们可以通过在 componentDidUpdate 中添加对 prevProps 或 prevState 的比较逻辑解决： 12345componentDidUpdate(prevProps, prevState) { if (prevState.count !== this.state.count) { document.title = `You clicked ${this.state.count} times`; }} Hook中可以使用第二个参数： 123useEffect(() =&gt; { document.title = `You clicked ${count} times`;}, [count]); // 仅在 count 更改时更新 Hook 规则只在最顶层使用 Hook不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。 只在 React 函数中调用 Hook不要在普通的 JavaScript 函数中调用 Hook。你可以： ✅ 在 React 的函数组件中调用 Hook ✅ 在自定义 Hook 中调用其他 Hook 自定义 Hook通过自定义 Hook，可以将组件逻辑提取到可重用的函数中。 提取自定义 Hook当我们想在两个函数之间共享逻辑时，我们会把它提取到第三个函数中。而组件和 Hook 都是函数，所以也同样适用这种方式。 自定义 Hook 是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook。 例如： 1234567891011121314151617import { useState, useEffect } from 'react';function useFriendStatus(friendID) { const [isOnline, setIsOnline] = useState(null); useEffect(() =&gt; { function handleStatusChange(status) { setIsOnline(status.isOnline); } ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () =&gt; { ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); }; }); return isOnline;} 使用自定义 Hook1234567function FriendStatus(props) { const isOnline = useFriendStatus(props.friend.id); if (isOnline === null) { return 'Loading...'; } return isOnline ? 'Online' : 'Offline';} 12345678function FriendListItem(props) { const isOnline = useFriendStatus(props.friend.id); return ( &lt;li style={{ color: isOnline ? 'green' : 'black' }}&gt; {props.friend.name} &lt;/li&gt; );}","link":"/2021/01/12/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/react/hook/"},{"title":"react——代码分割","text":"打包大多数 React 应用都会使用 Webpack，Rollup 或 Browserify 这类的构建工具来打包文件。 打包是一个将文件引入并合并到一个单独文件的过程，最终形成一个 “bundle”。 接着在页面上引入该 bundle，整个应用即可一次性加载。 示例App文件： 1234// app.jsimport { add } from './math.js';console.log(add(16, 26)); // 42 1234// math.jsexport function add(a, b) { return a + b;} 打包后文件： 12345function add(a, b) { return a + b;}console.log(add(16, 26)); // 42 代码分割但随着应用增长，代码包也将随之增长。尤其是在整合了体积巨大的第三方库的情况下。你需要关注你代码包中所包含的代码，以避免因体积过大而导致加载时间过长。 代码分割是由诸如 Webpack，Rollup 和 Browserify（factor-bundle）这类打包器支持的一项技术，能够创建多个包并在运行时动态加载。 对你的应用进行代码分割能够帮助你“懒加载”当前用户所需要的内容，能够显著地提高你的应用性能。尽管并没有减少应用整体的代码体积，但你可以避免加载用户永远不需要的代码，并在初始加载的时候减少所需加载的代码量。 以下是几种代码分割的方式： import()在你的应用中引入代码分割的最佳方式是通过动态 import() 语法。 使用之前： 123import { add } from './math';console.log(add(16, 26)); 使用之后： 123import(&quot;./math&quot;).then(math =&gt; { console.log(math.add(16, 26));});ja 前提：使用Create React App或者自己配置webpack React.lazyReact.lazy 函数能让你像渲染常规组件一样处理动态引入（的组件）。不过不支持服务端渲染。 使用之前： 1import OtherComponent from './OtherComponent'; 使用之后： 1const OtherComponent = React.lazy(() =&gt; import('./OtherComponent')); 此代码将会在组件首次渲染时，自动导入包含 OtherComponent 组件的包。 React.lazy 接受一个函数，这个函数需要动态调用 import()。它必须返回一个 Promise，该 Promise 需要 resolve 一个 defalut export 的 React 组件。 然后应在 Suspense 组件中渲染 lazy 组件，如此使得我们可以使用在等待加载 lazy 组件时做优雅降级（如 loading 指示器等）。 12345678910111213import React, { Suspense } from 'react';const OtherComponent = React.lazy(() =&gt; import('./OtherComponent'));function MyComponent() { return ( &lt;div&gt; &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt; &lt;OtherComponent /&gt; &lt;/Suspense&gt; &lt;/div&gt; );} fallback 属性接受任何在组件加载过程中你想展示的 React 元素。你可以将 Suspense 组件置于懒加载组件之上的任何位置。你甚至可以用一个 Suspense 组件包裹多个懒加载组件。 1234567891011121314151617import React, { Suspense } from 'react';const OtherComponent = React.lazy(() =&gt; import('./OtherComponent'));const AnotherComponent = React.lazy(() =&gt; import('./AnotherComponent'));function MyComponent() { return ( &lt;div&gt; &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt; &lt;section&gt; &lt;OtherComponent /&gt; &lt;AnotherComponent /&gt; &lt;/section&gt; &lt;/Suspense&gt; &lt;/div&gt; );} 异常捕获边界（Error boundaries）如果模块加载失败（如网络问题），它会触发一个错误。你可以通过异常捕获边界（Error boundaries）技术来处理这些情况，以显示良好的用户体验并管理恢复事宜。 123456789101112131415161718import React, { Suspense } from 'react';import MyErrorBoundary from './MyErrorBoundary';const OtherComponent = React.lazy(() =&gt; import('./OtherComponent'));const AnotherComponent = React.lazy(() =&gt; import('./AnotherComponent'));const MyComponent = () =&gt; ( &lt;div&gt; &lt;MyErrorBoundary&gt; &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt; &lt;section&gt; &lt;OtherComponent /&gt; &lt;AnotherComponent /&gt; &lt;/section&gt; &lt;/Suspense&gt; &lt;/MyErrorBoundary&gt; &lt;/div&gt;); 基于路由的代码分割决定在哪引入代码分割需要一些技巧。你需要确保选择的位置能够均匀地分割代码包而不会影响用户体验。 一个不错的选择是从路由开始。大多数网络用户习惯于页面之间能有个加载切换过程。你也可以选择重新渲染整个页面，这样您的用户就不必在渲染的同时再和页面上的其他元素进行交互。 这里是一个例子，展示如何在你的应用中使用 React.lazy 和 React Router 这类的第三方库，来配置基于路由的代码分割。 12345678910111213141516import React, { Suspense, lazy } from 'react';import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';const Home = lazy(() =&gt; import('./routes/Home'));const About = lazy(() =&gt; import('./routes/About'));const App = () =&gt; ( &lt;Router&gt; &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt; &lt;Switch&gt; &lt;Route exact path=&quot;/&quot; component={Home}/&gt; &lt;Route path=&quot;/about&quot; component={About}/&gt; &lt;/Switch&gt; &lt;/Suspense&gt; &lt;/Router&gt;); 命名导出（Named Exports）React.lazy 目前只支持默认导出（default exports）。如果你想被引入的模块使用命名导出（named exports），你可以创建一个中间模块，来重新导出为默认模块。这能保证 tree shaking 不会出错，并且不必引入不需要的组件。 123// ManyComponents.jsexport const MyComponent = /* ... */;export const MyUnusedComponent = /* ... */; 12// MyComponent.jsexport { MyComponent as default } from &quot;./ManyComponents.js&quot;; 123// MyApp.jsimport React, { lazy } from 'react';const MyComponent = lazy(() =&gt; import(&quot;./MyComponent.js&quot;));","link":"/2021/01/10/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/react/%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2/"},{"title":"react——高阶组件","text":"高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。具体看官网。 具体而言，高阶组件是参数为组件，返回值为新组件的函数。 1const EnhancedComponent = higherOrderComponent(WrappedComponent); 组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件。 例子： 12345678910111213141516171819202122232425262728293031323334// 此函数接收一个组件...function withSubscription(WrappedComponent, selectData) { // ...并返回另一个组件... return class extends React.Component { constructor(props) { super(props); this.handleChange = this.handleChange.bind(this); this.state = { data: selectData(DataSource, props) }; } componentDidMount() { // ...负责订阅相关的操作... DataSource.addChangeListener(this.handleChange); } componentWillUnmount() { DataSource.removeChangeListener(this.handleChange); } handleChange() { this.setState({ data: selectData(DataSource, this.props) }); } render() { // ... 并使用新数据渲染被包装的组件! // 请注意，我们可能还会传递其他属性 return &lt;WrappedComponent data={this.state.data} {...this.props} /&gt;; } };} 请注意，HOC 不会修改传入的组件，也不会使用继承来复制其行为。相反，HOC 通过将组件包装在容器组件中来组成新组件。HOC 是纯函数，没有副作用。","link":"/2021/01/11/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/react/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/"},{"title":"js设计模式","text":"demo","link":"/2021/08/16/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/javaScript/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"Web Workers","text":"Web WorkersWeb Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。此外，他们可以使用XMLHttpRequest执行 I/O (尽管responseXML和channel属性总是为空)。一旦创建， 一个worker 可以将消息发送到创建它的JavaScript代码, 通过将消息发布到该代码指定的事件处理程序（反之亦然）。 专用worker一个专用worker仅仅能被生成它的脚本所使用。 生成一个专用worker1var myWorker = new Worker('worker.js'); 专用worker中消息的接收和发送其中e.data是传过来的消息。 1234567myWorker.postMessage();//主线程发送给worker（main.js）onmessage = function(e) { console.log(e.data) }//worker接收主线程的消息（worker.js）postMessage();//worker发送给主线程（worker.js）myWorker.onmessage = function(e) { console.log(e.data) }//主线程接收worker的消息（main.js） 终止worker123myWorker.terminate();//主线程终止close();//worker终止 第一次的时候还是会接收到主线程传来的消息 处理错误当 worker 出现运行中错误时，它的 onerror 事件处理函数会被调用。它会收到一个扩展了 ErrorEvent 接口的名为 error的事件。 错误事件有以下三个用户关心的字段： message 可读性良好的错误消息。 filename 发生错误的脚本文件名。 lineno 发生错误时所在脚本文件的行号。 生成subworker如果需要的话 worker 能够生成更多的 worker。这就是所谓的subworker，它们必须托管在同源的父页面内。而且，subworker 解析 URI 时会相对于父 worker 的地址而不是自身页面的地址。这使得 worker 更容易记录它们之间的依赖关系。 引入脚本与库Worker 线程能够访问一个全局函数importScripts()来引入脚本，该函数接受0个或者多个URI作为参数来引入资源；以下例子都是合法的： 123importScripts(); /* 什么都不引入 */importScripts('foo.js'); /* 只引入 &quot;foo.js&quot; */importScripts('foo.js', 'bar.js'); /* 引入两个脚本 */ 共享worker一个共享worker可以被多个脚本使用——即使这些脚本正在被不同的window、iframe或者worker访问。 生成一个共享worker1var myWorker = new SharedWorker('worker.js'); 一个非常大的区别在于，与一个共享worker通信必须通过端口对象——一个确切的打开的端口供脚本与worker通信（在专用worker中这一部分是隐式进行的）。 在传递消息之前，端口连接必须被显式的打开，打开方式是使用onmessage事件处理函数或者**start()**方法。 start()方法的调用只在一种情况下需要，那就是消息事件被**addEventListener()**方法使用。 在使用start()方法打开端口连接时，如果父级线程和worker线程需要双向通信，那么它们都需要调用start()方法。 12myWorker.port.start(); // 父级线程中的调用port.start(); // worker线程中的调用, 假设port变量代表一个端口 共享worker中消息的接收和发送首先，当一个端口连接被创建时（例如：在父级线程中，设置onmessage事件处理函数，或者显式调用start()方法时），使用onconnect事件处理函数来执行代码。 12myWorker.port.postMessage();//主线程发送消息myWorker.port.onmessage = function(e) {}//主线程接收消息 1234567onconnect = function(e) {//连接 var port = e.ports[0]; port.onmessage = function(e) {//子线程worker接收消息 port.postMessage(workerResult);//子线程woker发送消息 }} 嵌入式 worker目前没有一种「官方」的方法能够像 `` 元素一样将 worker 的代码嵌入的网页中。但是如果一个 `` 元素没有 src 特性，并且它的 type 特性没有指定成一个可运行的 mime-type，那么它就会被认为是一个数据块元素，并且能够被 JavaScript 使用。「数据块」是 HTML5 中一个十分常见的特性，它可以携带几乎任何文本类型的数据。所以，你能够以如下方式嵌入一个 worker： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot; /&gt;&lt;title&gt;MDN Example - Embedded worker&lt;/title&gt;&lt;script type=&quot;text/js-worker&quot;&gt; // 该脚本不会被 JS 引擎解析，因为它的 mime-type 是 text/js-worker。 var myVar = &quot;Hello World!&quot;; // 剩下的 worker 代码写到这里。&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 该脚本会被 JS 引擎解析，因为它的 mime-type 是 text/javascript。 function pageLog (sMsg) { // 使用 fragment：这样浏览器只会进行一次渲染/重排。 var oFragm = document.createDocumentFragment(); oFragm.appendChild(document.createTextNode(sMsg)); oFragm.appendChild(document.createElement(&quot;br&quot;)); document.querySelector(&quot;#logDisplay&quot;).appendChild(oFragm); }&lt;/script&gt;&lt;script type=&quot;text/js-worker&quot;&gt; // 该脚本不会被 JS 引擎解析，因为它的 mime-type 是 text/js-worker。 onmessage = function (oEvent) { postMessage(myVar); }; // 剩下的 worker 代码写到这里。&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 该脚本会被 JS 引擎解析，因为它的 mime-type 是 text/javascript。 // 在过去...： // 我们使用 blob builder // ...但是现在我们使用 Blob...: var blob = new Blob(Array.prototype.map.call(document.querySelectorAll(&quot;script[type=\\&quot;text\\/js-worker\\&quot;]&quot;), function (oScript) { return oScript.textContent; }),{type: &quot;text/javascript&quot;}); // 创建一个新的 document.worker 属性，包含所有 &quot;text/js-worker&quot; 脚本。 document.worker = new Worker(window.URL.createObjectURL(blob)); document.worker.onmessage = function (oEvent) { pageLog(&quot;Received: &quot; + oEvent.data); }; // 启动 worker. window.onload = function() { document.worker.postMessage(&quot;&quot;); };&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;logDisplay&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 其它类型的worker除了专用和共享的web worker，还有一些其它类型的worker： ServiceWorkers （服务worker）一般作为web应用程序、浏览器和网络（如果可用）之前的代理服务器。它们旨在（除开其他方面）创建有效的离线体验，拦截网络请求，以及根据网络是否可用采取合适的行动并更新驻留在服务器上的资源。他们还将允许访问推送通知和后台同步API。 Chrome Workers 是一种仅适用于firefox的worker。如果您正在开发附加组件，希望在扩展程序中使用worker且有在你的worker中访问 js-ctypes 的权限，你可以使用Chrome Workers。详情请参阅ChromeWorker。 Audio Workers （音频worker）使得在web worker上下文中直接完成脚本化音频处理成为可能。 worker中可用的函数和接口你可以在web worker中使用大多数的标准javascript特性，包括 Navigator XMLHttpRequest Array, Date, Math, and String WindowTimers.setTimeout (en-US) and WindowTimers.setInterval (en-US) 在一个worker中最主要的你不能做的事情就是直接影响父页面。包括操作父页面的节点以及使用页面中的对象。你只能间接地实现，通过DedicatedWorkerGlobalScope.postMessage (en-US)回传消息给主脚本，然后从主脚本那里执行操作或变化。","link":"/2022/03/15/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/javaScript/web%20workers/"},{"title":"npm发包流程","text":"官网 npm发布包相关操作 登录：npm login 发布及更新：npm publish 更新版本：执行以下命令后 npm publish npm version patch作用将修订号增加1，也就是版本号最后一位 npm version minor将次版本号增加1，也就是中间那一位 npm version major将主版本号增加1，也就是第一位 删除版本：npm unpublish 包名@版本号 删除整个包：npm unpublish 包名 –force","link":"/2022/01/25/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/npm/npm/"},{"title":"前端常用方法库","text":"简介这是一个封装的前端常用方法的npm库，目前主要功能有拖拽，防抖节流，后续会继续添加方法。 库本身使用typeScript作为开发语言，webpack工具进行打包。 源码地址 MakeDomMove这个方法可以让元素根据鼠标按下后拖拽移动，传入2个必填和一个选填参数。 第一个必填参数是父元素，可以传字符串如.father或者传dom，如果传null或false则默认为body。 第二个必填参数为子元素，即可以拖拽移动的元素，方式和父元素一样。 第三个选填参数为其他选项，可以传一个对象，对象里面有isLazy和waitTime两个字段，即是否开启节流和节流时间。 生成的实例有两个方法makeMove和clear，makeMove即开启拖拽移动功能，clear则是清除相关事件。 使用1234import { MakeDomMove } from 'zhb-common-utils';let m = new MakeDomMove('.father', '.child', {isLazy: true, waitTime: 200});//初始化m.makeMove();//使用m.clear();//清除事件 拖拽前： 拖拽后： debounce这个方法是防抖方法，传入3个参数。 第一个为执行的函数。 第二个为等待的时间。 第三个为是否立即执行 使用12import { debounce } from 'zhb-common-utils';document.addEventListener('mousemove', debounce(function(e){}, 200, false)): throttle这个方法是节流方法，传入3个参数。 第一个为执行的函数。 第二个为等待的时间。 第三个是一个对象，有两个参数， trailing结束后是否执行一次 leading是否立即执行 使用12import { throttle } from 'zhb-common-utils';document.addEventListener('mousemove', throttle(function(e){}, 200, {trailing: false, leading: false})):","link":"/2022/02/18/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/npm/%E6%8B%96%E6%8B%BD%E5%BA%93/"},{"title":"three.js基础学习","text":"以下是学习的相关地址，有各个部分功能的文档及相关demo。 学习地址","link":"/2022/04/01/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/three/%E5%9F%BA%E7%A1%80/"},{"title":"webRTC学习","text":"这是一个关于WebRTC学习的记录。相关文档记录在 webRtcDemo。","link":"/2023/01/21/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/webRTC/webRTC%E5%AD%A6%E4%B9%A0/"},{"title":"实时通讯","text":"这是一个可以进行实时通讯的网页demo，是对WebRTC的一些学习成果。主要功能有视频通讯和文字聊天，分为客户端和信令服务器。 源码地址 客户端客户端由React框架进行编写，核心代码主要有以下两部分： websocket连接通讯使用socket.io-client库与客户端的socket.io进行数据交换，实现对等连接。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import { io, Socket } from 'socket.io-client';let { REACT_APP_PUBLICHOST: host, REACT_APP_PUBLICPOINT: point } = process.env;interface Option { onConnect?: () =&gt; void, onJoined?: (message: { roomId: string; userNum: number }) =&gt; void; onOtherJoined?: (message: { roomId: string; userId: number }) =&gt; void; onMessage: (data: { type: string; value: any }) =&gt; void; onFull?: (message: { roomId: string }) =&gt; void; onBye?: (message: { roomId: string; userId: number }) =&gt; void; onLeaved?: (message: { roomId: string }) =&gt; void; serverUrl?: string;}export default class SignalServer { socket!: Socket; roomId!: string | number; constructor(option: Option) { this.init(option); } init(option: Option) { this.socket = io(option.serverUrl || `http://${host}:${point}/`); this.socket.connect(); this.socket.on( 'connect', //判断socket是否已连接 option.onConnect || (() =&gt; { console.log('socket connected'); }) ) this.socket.on( 'joined', option.onJoined || (({ roomId, usersNum }) =&gt; { console.log('i joined a room', roomId); console.log('current user number:', usersNum); }), ); this.socket.on( 'otherjoined', option.onOtherJoined || (({ roomId, userId }) =&gt; { console.log('other user joined, userId', userId); }), ); this.socket.on('message', option.onMessage); this.socket.on( 'full', option.onFull || (({ roomId }) =&gt; { console.log(roomId, 'is full'); }), ); this.socket.on( 'bye', option.onBye || (({ roomId, userId }) =&gt; { console.log(userId, `leaved`, roomId); }), ); this.socket.on('leaved', option.onLeaved || (({ roomId }) =&gt; { })); window.addEventListener('beforeunload', () =&gt; { this.leave(); }); } send(data: unknown) { if (!this.roomId) return; this.socket.emit('message', { roomId: this.roomId, data }); } join(roomId: string | number) { this.roomId = roomId; this.socket.emit('join', { roomId }); } leave() { this.roomId &amp;&amp; this.socket.emit('leave', { roomId: this.roomId }); this.roomId = ''; }} WebRTC相关内容主要使用WebRTC相关的api，有以下几个关键的api。 navigator.mediaDevices.getUserMedia() new RTCPeerConnection() createDataChannel() 其中**navigator.mediaDevices.getUserMedia()获取可以打开摄像头和麦克风。new RTCPeerConnection()是对等连接相关，只有连接了才能进行通讯。createDataChannel()**则是开启数据通道，在对接连接成功之后。 核心的步骤如下： 初始化信令服务器 1234useEffect(() =&gt; { // 初始化信令服务器 signalServer.current = new SignalServer({ onMessage, onJoined, onOtherJoined, onConnect });}, []); 初始化本地pc对象，其中数据通道也可以在以下步骤初始化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 初始化本地pc对象 const initPeerConnection = () =&gt; { setConnectLoading(true); console.log('------ 初始化本地pc对象'); // 创建pc实例 peerConnection.current = new RTCPeerConnection(pcOption); const pc = peerConnection.current; // 监听 candidate 获取事件 pc.addEventListener('icecandidate', event =&gt; { const candidate = event.candidate; if (candidate) { console.log('------ 获取到了本地 candidate：', candidate); // 发送candidate到远端 signalServer?.current?.send({ type: 'candidate', value: candidate }); } }); // 监听到远端传过来的媒体数据 pc.addEventListener('track', e =&gt; { console.log('------ 获取到了远端媒体数据：', e); if (remoteVideo.current &amp;&amp; remoteVideo.current.srcObject !== e.streams[0]) { remoteVideo.current.srcObject = e.streams[0]; } }); // 监听对等连接状态 pc.addEventListener('connectionstatechange', event =&gt; { console.log('当前对等连接状态', pc.connectionState) if (pc.connectionState === 'connected') { setState('connected'); } else if (['disconnected', 'failed'].includes(pc.connectionState)) { unCall(); } }); // 创建通道 dataChannel.current = pc.createDataChannel('sendDataChannel'); // 监听通道 peerConnection?.current?.addEventListener('datachannel', onGetRemoteDatachannel); //监听通道打开 dataChannel.current.addEventListener('open', (e) =&gt; { console.log('------ 本地通道已打开：', e); }) //监听通道关闭 dataChannel.current.addEventListener('close', (e) =&gt; { console.log('------ 本地通道已关闭：', e); }) }; 获取本地媒体数据并绑定到pc对象上。 123456789101112131415161718192021222324252627282930// 获取本地媒体数据 const getLocalMediaStream = () =&gt; { return new Promise((resolve, reject) =&gt; { navigator.mediaDevices.getUserMedia({ audio: false, video: { width: { ideal: 500 }, height: { ideal: 500 }, } }).then(mediaStream =&gt; { console.log('------ 成功获取本地设备媒体数据:', mediaStream); if (mediaStream) { if (localVideo.current) localVideo.current.srcObject = mediaStream; localMediaStream.current = mediaStream; // 绑定本地媒体数据到pc对象上 if (localMediaStream.current) { console.log('------ 绑定本地媒体数据到pc对象上'); localMediaStream.current.getTracks().forEach(track =&gt; { if (peerConnection.current) peerConnection.current.addTrack(track, localMediaStream.current as MediaStream); }); resolve('addTrackDown'); } } }); }) }; 建立对等连接 建立对等连接需先进行websoket连接，以便数据交换，在第一步初始化的时候便已建立连接，接下来则是一些逻辑判断，如同一个房间下才能进行通讯。 12345678910111213141516171819202122232425// 加入房间 const join = () =&gt; { if (state !== 'disconnect') return message.error('请先启动信令服务器'); if (!roomId) return message.error('请输入房间号'); signalServer?.current?.join(roomId); setState('waiting'); }; // 已加入房间 const onJoined = ({ roomId, userNum }: { roomId: string | number, userNum: string | number }) =&gt; { message.success('成功加入房间,当前房间人数为:' + userNum); console.log('------ 成功加入房间,当前房间人数为:' + userNum); if (userNum === 1) { setState('waiting'); } else { setState('canCall'); } }; // 其他人加入房间 const onOtherJoined = (data: unknown) =&gt; { console.log('------ 有人加入房间了'); setState('canCall'); }; 接下来就是对等连接的建立，通过信令服务器（webSocket）交换offer和answer及candidate，并设置本地和远程描述，最后设置远端ICE。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 发起通讯 const call = async () =&gt; { if (state !== 'canCall') return; await connectFunc(); // 开始建立连接 const pc = peerConnection.current; // 获取本地sdp(offer) pc?.createOffer().then(offer =&gt; { console.log('------ 获取到了本地offer', offer); // 绑定本地sdp pc.setLocalDescription(offer); // 发送本地sdp到远端 signalServer?.current?.send({ type: 'offer', value: offer, }); }); }; // 获取远端offer const onGetRemoteOffer = async (offer: RTCSessionDescription) =&gt; { console.log('------ 获取到了远端offer', offer); await connectFunc(); const pc = peerConnection.current; // 绑定远端sdp pc?.setRemoteDescription(offer); isSetRemoteSdpResolve(''); // 创建本地sdp pc?.createAnswer().then(answer =&gt; { // 绑定本地sdp pc.setLocalDescription(answer); console.log('------ 获取到了本地answer', answer); // 发送本地sdp到远端 signalServer?.current?.send({ type: 'answer', value: answer, }); }); };// 获取远端answer const onGetRemoteAnswer = (answer: RTCSessionDescription) =&gt; { console.log('------ 获取到了远端answer', answer); const pc = peerConnection.current; // 绑定远端sdp pc?.setRemoteDescription(answer); isSetRemoteSdpResolve(''); };// 获取到远端的candidate const onGetRemoteCandidate = async (candidate: RTCIceCandidateInit | RTCIceCandidate) =&gt; { await isSetRemoteSdpPromise; console.log('------ 获取到了远端candidate', candidate); peerConnection?.current?.addIceCandidate(candidate); }; 数据通道数据交换 数据通道在对等连接建立成功之后即可交换数据，通过**dataChannel.send()**方法进行数据交换。 123456789101112131415161718192021222324252627282930313233343536//发送消息 const sendMsg = () =&gt; { if (dataChannel.current &amp;&amp; msg) { setMsgList([...msgList, { id: msgList.length + 1, name: '我', text: msg, isLocal: true }]); setMsg(''); dataChannel.current.send(msg); } } // 获取远端datachannel const onGetRemoteDatachannel = (event: RTCDataChannelEvent) =&gt; { const dc = event.channel; console.log('------ 获取到了远端通道', event.channel); //监听通道消息 dc.addEventListener('message', (e: MessageEvent&lt;any&gt;) =&gt; { setMsgList(msgList =&gt; [...msgList, { id: msgList.length + 1, name: '他', text: e.data, isLocal: false }]); console.log('------ 远端通道消息：', e); }) //监听通道打开 dc.addEventListener('open', (e) =&gt; { console.log('------ 远端通道已打开：', e); }) //监听通道关闭 dc.addEventListener('close', (e) =&gt; { console.log('------ 远端通道已关闭：', e); }) } 信令服务器端信令服务器的作用主要是通过websocket进行数据交换，建立对等连接，当然也可以通过ajax请求，不过websocket更加方便一些。 由express和socket.io库实现的简单websocket信令服务器，具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110'use strict ';let http = require('http'); // 提供HTTP 服务const { Server } = require('socket.io');let express = require('express');const MaxUserNum = 2;let app = express();const roomsInfo = {};const userRoomInfo = {};//HTTP 服务let http_server = http.createServer(app);http_server.listen(8091, '0.0.0.0', () =&gt; { console.log('listening on *:8091');});const io = new Server(http_server, { cors: { origin: ['http://127.0.0.1:8090', 'http://localhost:8090', 'http://175.178.107.242:8090'], credentials: true, },});// 处理连接事件io.sockets.on('connection', socket =&gt; { console.log('got a connection'); // 用于转发sdp、candidate等消息 socket.on('message', ({ roomId, data }) =&gt; { console.log('message , room: ' + roomId + ', data , type:' + data.type); socket.to(roomId).emit('message', data); }); socket.on('join', ({ roomId }) =&gt; { if (!roomId) return; //加入房间 socket.join(roomId); console.log(`${socket.id} join ${roomId}`); // 登记房间用户 if (!roomsInfo[roomId]) { roomsInfo[roomId] = {}; } roomsInfo[roomId][socket.id] = socket; //登记用户房间 if (!userRoomInfo[socket.id]) { userRoomInfo[socket.id] = []; } userRoomInfo[socket.id].push(roomId); let userNum = Object.keys(roomsInfo[roomId]).length; // 如果房间里人未满 if (userNum &lt;= MaxUserNum) { // 回复用户已经加入到房间里了 socket.emit('joined', { roomId, userNum }); // 通知另一个用户， 有人来了 if (userNum &gt; 1) { //向roomId的所有连接用户的群发消息 socket.to(roomId).emit('otherjoined', { roomId, userId: socket.id }); } } else { // 如果房间里人满了，离开房间 socket.leave(roomId); // 回复用户房间满人了 socket.emit('full', { roomId, userNum }); } }); const onLeave = ({ roomId }) =&gt; { if (!roomId) return; socket.leave(roomId); roomsInfo[roomId] &amp;&amp; roomsInfo[roomId][socket.id] &amp;&amp; delete roomsInfo[roomId][socket.id]; userRoomInfo[socket.id] &amp;&amp; (userRoomInfo[socket.id] = userRoomInfo[socket.id].filter(id =&gt; id !== roomId)); console.log( 'someone leaved the room, the user number of room is: ', roomsInfo[roomId] ? Object.keys(roomsInfo[roomId]).length : 0, ); // 通知其他用户有人离开了 socket.to(roomId).emit('bye', { roomId, userId: socket.id }); // 回复用户你已经离开房间了 socket.emit('leaved', { roomId }); }; // 用户离开房间 socket.on('leave', onLeave); //disconnect socket.on('disconnect', () =&gt; { console.log(socket.id, 'disconnect, and clear user`s Room', userRoomInfo[socket.id]); if (userRoomInfo[socket.id]) { userRoomInfo[socket.id].forEach(roomId =&gt; { onLeave({ roomId }); }); delete userRoomInfo[socket.id]; } });}); STUN/TRUN服务器数据流需要内网穿透，才能进行视频和数据的通讯，不然就只能在同一个局域网进行通讯，这时候就需要用到STUN/TRUN服务器。 这是通过coturn建立的STUN/TRUN服务器（网上教程）：coturn搭建STUN/TRUN服务器 其中需要注意，测试STUN/TRUN服务器的时候最好用火狐，google时不时会出错。 上线通过Jenkins和Docker进行构建和部署。 最终效果注意，由于WebRTC只能在本地或者https下使用，所以需要修改谷歌配置，将测试地址加入安全范围内。在谷歌地址栏中输入chrome://flags/，然后找到Insecure origins treated as secure，将其设置为Enabled，然后将地址填入下方输入框中。","link":"/2023/03/21/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/webRTC/%E5%AE%9E%E6%97%B6%E9%80%9A%E8%AE%AF/"},{"title":"vue+electron高仿网易云","text":"介绍 用vue+electron 高仿网易云pc版，后台api是网上一位大佬根据网易云api获取的 这是api地址：网易云api 后台文件到上面github地址下载，下载后的文件为NeteaseCloudMusicApi 安装教程 两个文件都需要npm install 安装完成后在 NeteaseCloudMusicApi 文件里启动node服务，node app.js 在 cloudmusic里启动vue，npm run dev 上线（已失效） 目前已上线阿里云，打包好的exe文件在百度云： 链接：https://pan.baidu.com/s/13VIKegK4mmSF1ds9FqP6mA 提取码：jq98 打开exe文件即可一键安装，然后在桌面直接打开即可 技术栈基本就是vue全家桶，还有外壳electron，后台api是网上一位大佬的 vue vuex axios vue-router electron node gif动图演示 功能介绍登录 可以根据自己的手机号登录网易云 查看个人收藏，包括歌曲，歌单，专辑，歌手 登录后即可查看这些信息，如下图 歌单大全，歌手大全，排行榜等 这是其中的一张，歌手大全 此外还有一些功能，如收藏，发表评论等 喜欢音乐 当然少不了音乐播放相关的操作如播放，暂停，下一首等操作","link":"/2019/06/13/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/vue/cloudmusic/"},{"title":"vite搭建ts版vue3移动端基础框架","text":"总览demo地址 开始初始化1npm init vite@latest my-vue-app 初始化一个项目，期间可以选中相应框架及语法 启动接着我们打开安装的目录，使用npm install安装相关依赖。之后只用npm run dev即可运行。 安装库安装下面相关的库，注意版本问题 vue-router（安装vue-router4.x版本进行路由控制） vuex（安装vuex4.x版本进行状态管理） element-plus（安装element-plus ui库） axios（安装axios http库方便网络请求） sass、sass-loader（安装sass和sass-loader支持sass语法） esri-loader（安装esri-loader便于引入arcgis） postcss-pxtorem（安装postcss-pxtorem转换px为rem，适配移动端） normalize.css（引入normalize.css初始化css） 配置在vite.config.ts和tsconfig.json里进行基础路径,别名及跨域等配置。 123456789101112131415161718192021222324252627282930313233343536373839//vite.config.tsimport { defineConfig, loadEnv } from 'vite'import vue from '@vitejs/plugin-vue'import vueJsx from '@vitejs/plugin-vue-jsx'import Components from 'unplugin-vue-components/vite'import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'const { resolve } = require('path')function _resolve(path: string): string { return resolve(__dirname, path)}// https://vitejs.dev/config/export default defineConfig(({mode}) =&gt; { const env = loadEnv(mode, __dirname) return { base: './', plugins: [ vue(), vueJsx(), Components({ resolvers: [ElementPlusResolver()], }), ], resolve: { // 配置别名 alias: { '@': _resolve('./src'), }, }, server: { proxy: { '/local': { target: env.VITE_NORMALURL, rewrite: path =&gt; path.replace(/^\\/local/, ''), changeOrigin: true, } } } }}) 1234567891011121314151617181920212223//tsconfig.json{ &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;esnext&quot;, &quot;useDefineForClassFields&quot;: true, &quot;module&quot;: &quot;esnext&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;strict&quot;: true, &quot;jsx&quot;: &quot;preserve&quot;, &quot;sourceMap&quot;: true, &quot;resolveJsonModule&quot;: true, &quot;esModuleInterop&quot;: true, &quot;experimentalDecorators&quot;: true, &quot;lib&quot;: [&quot;esnext&quot;, &quot;dom&quot;, &quot;DOM.Iterable&quot;], &quot;baseUrl&quot;: &quot;./&quot;, &quot;paths&quot;:{ &quot;@&quot;: [&quot;src&quot;], &quot;@/*&quot;: [&quot;src/*&quot;], }, }, &quot;include&quot;: [&quot;src/**/*.ts&quot;, &quot;src/**/*.d.ts&quot;, &quot;src/**/*.tsx&quot;, &quot;src/**/*.vue&quot;]} 工具函数与类缓存桶提高移动端下拉列表的用户体验。将数据先缓存起来，下拉到底的时候先拿缓存的数据，期间判断并请求接口，用户几乎感知不到卡顿。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117import {toRefs} from 'vue';import { request, DataIn } from &quot;@/request&quot;;import { deepClone } from &quot;@/utils&quot;interface Data extends DataIn { limit: number}interface RequestOption { name: string, data: Data, recordKey ?: string}//缓存桶类class CacheBucket { constructor() {} public cacheList: Array&lt;any&gt; = [];//缓存的数据列表 public copyRes: any = null;//缓存的返回结果 public defalutCount: number = 20;//默认一次返回数量 public requestOption: RequestOption = {name: '', data: {limit: 0}};//请求和返回相关参数 //初始化 public init(requestOption: RequestOption, defalutCount: number) { let { limit } = requestOption.data if(defalutCount &gt; limit) { throw new SyntaxError(`defalutCount不能大于limit`); } this.defalutCount = defalutCount !== undefined ? defalutCount : requestOption ? limit / 2 : this.defalutCount this.requestOption = requestOption || {} } //获取列表 public getList() { return new Promise((resolve: any, reject: any) =&gt; { if(this.cacheList.length &gt; this.defalutCount) { this.requestList(resolve, reject, false, false) } else if(this.cacheList.length === this.defalutCount) { this.requestList(resolve, reject, false) } else { this.requestList(resolve, reject) } }) } /** * 请求列表 * @param resolve * @param reject * @param isHandle 是否使用handleResult方法 * @param isRequest 是否请求接口 */ private requestList(resolve: any, reject: any, isHandle: boolean = true, isRequest: boolean = true) { let {name, data, recordKey} = this.requestOption if(!isHandle) { if(recordKey) { this.copyRes[recordKey] = this.cacheList.splice(0, this.defalutCount) } else { this.copyRes = this.cacheList.splice(0, this.defalutCount) } let result = { res: this.copyRes, isRequest: isRequest ? true : false } resolve(result) } if(isRequest) { request({ name, data }).then( (res: any) =&gt; { if(isHandle) { this.handleResult(resolve, res); } else { let data = recordKey ? res[recordKey] : res this.cacheList = this.cacheList.concat(data) } }).catch((err: any) =&gt; { reject(err) }) } } //处理请求结果 private handleResult(resolve: any, res: any) { this.copyRes = deepClone(res) let { recordKey } = this.requestOption if(recordKey) { this.copyRes[recordKey] = this.handleRecord(res[recordKey]) } else { this.copyRes = this.handleRecord(res) } let result = { res: this.copyRes, isRequest: true } resolve(result) } /** * 处理列表 * @param data 列表 * @returns */ private handleRecord(data: any) { let record: Array&lt;any&gt; = []; this.cacheList = this.cacheList.concat(data) record = this.cacheList.splice(0, this.defalutCount) return record } /** * 获取缓存数据 */ public getCacheList() { return this.cacheList }}export default CacheBucket 图片懒加载图片出现在视图内才进行请求，节约资源。 12345678910111213141516171819202122232425262728293031//图片懒加载class ImgLazyLoad { constructor() {} public imgList: Array&lt;any&gt; = [];//图片列表 public length: number = 0;//图片总数 public init() { this.imgList = [...document.querySelectorAll('img')]; this.length = this.imgList.length; document.addEventListener('scroll', this.imgLazyLoad) } private imgLazyLoad = (() =&gt; { let count = 0 return () =&gt; { let deleteIndexList: Array&lt;number&gt; = [] this.imgList.forEach((img: any, index: number) =&gt; { let rect = img.getBounding前端Rect() if (rect.top &lt; window.innerHeight) {//滚动到视图内触发 img.src = img.dataset.src deleteIndexList.push(index) count++ if (count === length) { document.removeEventListener('scroll', this.imgLazyLoad) } } }) this.imgList = this.imgList.filter((img: any, index: number) =&gt; !deleteIndexList.includes(index))//删除已加载的图片 } })()}export default ImgLazyLoad 构建和部署构建使用npm run build和npm run build-test分别构建测试和正式包。 部署编写Dockerfile，使用docker部署： 123FROM nginxMAINTAINER zhou COPY dist/ /usr/share/nginx/html/ 总结vite搭建的vue3版本的h5移动端框架，使用了vue全家桶及element ui库，并配置了一些实用的工具函数，可以完成项目开发的基本需求。","link":"/2021/12/17/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/vue/vite_vue/"},{"title":"vue2简单响应式原理","text":"介绍1、init 阶段： VUE 的 data的属性都会被reactive化，也就是加上 setter/getter函数。 1234567891011121314151617181920212223242526272829303132333435363738function defineReactive(obj: Object, key: string, ...) { const dep = new Dep() Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter () { .... dep.depend() return value .... }, set: function reactiveSetter (newVal) { ... val = newVal dep.notify() ... } }) } class Dep { static target: ?Watcher; subs: Array&lt;Watcher&gt;; depend () { if (Dep.target) { Dep.target.addDep(this) } } notify () { const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) { subs[i].update() } }} 其中这里的Dep就是一个调度中心（发布者），每一个data的属性都会有一个dep对象。当getter调用的时候，去dep里注册函数， setter的时候，就是去通知执行刚刚注册的函数。 2、mount 阶段： 123456789101112131415161718192021222324252627mountComponent(vm: Component, el: ?Element, ...) { vm.$el = el ... updateComponent = () =&gt; { //render生成虚拟dom，update生成渲染真实dom vm._update(vm._render(), ...) } new Watcher(vm, updateComponent, ...) ...}class Watcher { getter: Function; // 代码经过简化 constructor(vm: Component, expOrFn: string | Function, ...) { ... this.getter = expOrFn Dep.target = this // 注意这里将当前的Watcher赋值给了Dep.target this.value = this.getter.call(vm, vm) // 调用组件的更新函数 ... }} mount 阶段的时候，会创建一个Watcher类的对象。这个Watcher实际上是连接Vue组件与Dep的桥梁（观察者、订阅者）。每一个Watcher对应一个vue component。 这里可以看出new Watcher的时候，constructor 里的this.getter.call(vm, vm)函数会被执行。getter就是updateComponent。这个函数会调用组件的render函数来更新重新渲染。 而render函数里，会访问data的属性，比如 123render: function (createElement) { return createElement('h1', this.blogTitle)} 此时会去调用这个属性blogTitle的getter函数，即： 12345678910111213// getter函数get: function reactiveGetter () { .... dep.depend() return value .... },// dep的depend函数depend () { if (Dep.target) { Dep.target.addDep(this) }} 在depend的函数里，Dep.target就是watcher本身（我们在class Watch里讲过，不记得可以往上第三段代码），这里做的事情就是给blogTitle注册了Watcher这个对象。这样每次render一个vue 组件的时候，如果这个组件用到了blogTitle，那么这个组件相对应的Watcher对象都会被注册到blogTitle的Dep中。 这个过程就叫做依赖收集。 收集完所有依赖blogTitle属性的组件所对应的Watcher之后，当它发生改变的时候，就会去通知Watcher更新关联的组件。 3、更新阶段： 当blogTitle 发生改变的时候，就去调用Dep的notify函数,然后通知所有的Watcher调用update函数更新。 123456notify () { const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) { subs[i].update() }} 可以用一张图来表示： 由此图我们可以看出Watcher是连接VUE component 跟 data属性的桥梁。 总结最后，我们通过解释官方的图来做个总结。 1、第一步：组件初始化的时候，先给每一个Data属性都注册getter，setter，也就是reactive化。然后再new 一个自己的Watcher对象，此时watcher会立即调用组件的render函数去生成虚拟DOM。在调用render的时候，就会需要用到data的属性值，此时会触发getter函数，将当前的Watcher函数注册进sub里。 2、第二步：当data属性发生改变之后，就会遍历sub里所有的watcher对象，通知它们去重新渲染组件。","link":"/2020/10/27/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/vue/vue2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"},{"title":"Vue服务端渲染","text":"背景​ 传统的 php，jsp，asp 等运行在服务端的语言，它们都是等服务器端把数据和模板转换成最终的 HTML 并返回客户端显示。而如今前端主流的框架如Vue，React，Angular等基本都是基于客户端渲染，它们所构建的单页应用（SPA）具有渲染性能好、可维护性高等优点。但是带来的缺点也是明显的，如首屏加载时间过长、不利于SEO。​ 单页应用使用JavaScript在客户端生成HTML来呈现内容，用户需要等待JS解析执行完成才能看到页面，这就使得首屏加载时间变长，影响用户体验。此外当搜索引擎爬取网站HTML文件时，单页应用的HTML没有内容，从而影响搜索排名。​ 为了解决以上两点问题，可以对我们的应用程序使用服务器端渲染 (SSR) ，服务器渲染的 Vue.js 和React.js应用程序也可以被认为是”同构”或”通用”，因为应用程序的大部分代码都可以在服务器和客户端上运行。 vue服务端渲染方案 Nuxt.js 基础：vue Nuxt.js 是一个基于 Vue.js 的通用应用框架。通过对客户端/服务端基础架构的抽象组织，Nuxt.js 预设了利用 Vue.js 开发服务端渲染的应用所需要的各种配置。也就是说使用nuxt开发学习成本低，基本上学习过Vue.js都可以很快上手Nuxt.js。 demo 脚手架搭建, 基础：vue、webpack、node 但是，如果你需要更直接地控制应用程序的结构，Nuxt.js 并不适合这种使用场景，此时最好的方式就是从零开始搭建一个基于Vue的服务端渲染框架，可以参考官方指南 demo 实现Nuxt.js安装通过npx create-nuxt-app &lt;项目名&gt; 创建一个nuxt应用程序。（npx 在 NPM 版本 5.2.0 默认安装了） 目录结构介绍这是最后生成的文件目录结构 pages 这个文件夹一般存放页面文件，在执行npm run dev后会自动按规则生成对应的路由。 component 存放公用的组件，如loading等。 layout layouts 目录中的每个文件 (顶级) 都将创建一个可通过页面组件中的 layout 属性访问的自定义布局。 middleware 中间件目录，中间件允许您定义一个自定义函数运行在一个页面或一组页面渲染之前。执行顺序： nuxt.config.js 匹配布局 匹配页面 plugins Nuxt.js 允许你在运行 Vue.js 应用程序之前执行 js 插件。这在您需要使用自己的库或第三方模块时特别有用。使用方式：在plugins文件夹下创建一个模块js，如element-ui.js，然后再引入elementui并通过vue.use()方法注册，然后在nuxt.config.js中的plugins选项中加入该文件，由于是整个element引入，所以还得在css选项里加上element-ui的样式文件。这样我们就可以使用elementui的功能了。 路由nuxt.js可以自动生成路由，也可以手动配置。 自动生成可以根据nuxt的路由生成规则建立相应的文件结构，如下： 手动创建我们也可以手动创建路由，主要用到router选项下的extendRoutes创建自定义路由。例如：新建一个router.js文件，在里面写入以下代码，然后在nuxt.config.js里引入并使用，最后生成的就是我们的自定义路由。 1234567891011121314151617181920import Vue from 'vue'import Router from 'vue-router'Vue.use(Router)//() =&gt; import(/* webpackChunkName: &quot;index&quot; */'view/index.vue')export function createRouter() { return new Router({ mode: 'history', routes: [ { &quot;path&quot;: &quot;/&quot;, &quot;component&quot;: () =&gt; import(/* webpackChunkName: &quot;index&quot; */'view/index.vue') }, { &quot;path&quot;: &quot;/item/:id&quot;, &quot;component&quot;: () =&gt; import(/* webpackChunkName: &quot;item-_id-index&quot; */'view/item/_id/index.vue') } ] })} 生命周期钩子nuxt.js除了常见的vue生命周期外，还有多出来的两个生命周期钩子，asyncData和fetch asyncData 这个钩子在客户端和服务端都会执行，它可以是异步的，并接收上下文作为参数。返回的对象将与data对象合并。由于这个方法是在组件初始化之前被调用的，所以无法通过this来使用组件的方法和属性。 第一次加载页面时会先执行这个钩子，所有在这个时候不能使用document等客户端的对象和方法，否则会报错。由于除了页面刷新加载会执行这个钩子，在路由跳转或者组件生成时也会执行，所以需要通过process.server参数判断当前环境。 在服务端调用时，即页面刷新时，会等待promise状态完成后才会继续执行接下来的生命周期钩子。 fetch 每次需要获取异步数据时都可以使用fetch。fetch在服务器端呈现路由时调用，在客户端导航时调用。 在服务端调用时，即页面刷新时，会等待promise状态完成后才会继续执行接下来的生命周期钩子。 不同点你会发现这两者其实很相似，都可以同时在服务端和客户端执行，在服务端执行时也都是用于处理数据，但是他们还是有以下的不同点： asyncData只有在路由级页面能使用，即在注册了路由的组件才能使用，而fetch可以在所有vue组件下使用。 asyncData中无法使用组件的this，因为组件还未初始化完成，而fetch可以，更便于处理数据。 asyncData在服务端的执行时间在fetch和created之前，fetch在created之后，在客户端执行时asyncData依旧是排第一位，而fetch在beforeMount之后执行 其他除了以上讲的基础内容，还有一些其他内容，如自定义模块，路由动画和一些配置相关的就不细讲啦。 脚手架搭建在开始之前，首先需要准备的条件有： vue &amp; vue-server-renderer 2.3.0+ vue-router 2.5.0+ vue-loader 12.0.0+ &amp; vue-style-loader 3.0.0+ vuex express webpack及相关插件 起步 我们可以新建一个文件夹如vue-ssr,然后打开终端执行npm init生成package.json文件 然后先安装vue与vue-server-renderer和express进行测试（npm install vue vue-server-renderer express –save） 新建一个文件夹server.js 1234567891011121314151617181920212223242526272829const Vue = require('vue')const server = require('express')()const renderer = require('vue-server-renderer').createRenderer()server.get('*', (req, res) =&gt; { const app = new Vue({ data: { url: req.url }, template: `&lt;div&gt;访问的 URL 是： {{ url }}&lt;/div&gt;` }) renderer.renderToString(app, (err, html) =&gt; { if (err) { res.status(500).end('Internal Server Error') return } res.setHeader(&quot;Content-type&quot;,&quot;text/html;charset=utf8&quot;); res.end(` &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt; &lt;body&gt;${html}&lt;/body&gt; &lt;/html&gt; `) })})server.listen(8080) 这段代码的作用其实就是先创建一个vue实例，再创建一个renderer，通过renderer的renderToString方法将vue实例渲染为html，最后通过express创建的服务器，访问url后响应html到浏览器上最后在页面可以看到： 使用一个页面模板 我们现在可以用一个页面模板，然后将vue实例渲染的html写入到页面模板中，不过这个模板需要个HTML标记。这样才能正确的写入到模板中 模板支持一些简单的插值，我们可以通过传入一个”渲染上下文对象”，作为 renderToString 函数的第二个参数，来提供插值数据： 123456789101112&lt;html&gt; &lt;head&gt; &lt;!-- 使用双花括号(double-mustache)进行 HTML 转义插值(HTML-escaped interpolation) --&gt; &lt;title&gt;{{ title }}&lt;/title&gt; &lt;!-- 使用三花括号(triple-mustache)进行 HTML 不转义插值(non-HTML-escaped interpolation) --&gt; {{{ meta }}} &lt;/head&gt; &lt;body&gt; &lt;!--vue-ssr-outlet--&gt; &lt;/body&gt;&lt;/html&gt; server.js修改为： 12345678910111213141516171819202122232425262728293031const Vue = require('vue')const server = require('express')()const template = require('fs').readFileSync('./index.template.html', 'utf-8')const renderer = require('vue-server-renderer').createRenderer({ template})server.get('*', (req, res) =&gt; { const app = new Vue({ data: { url: req.url }, template: `&lt;div&gt;访问的 URL 是： {{ url }}&lt;/div&gt;` }) const context = { title: 'vue-ssr', meta: `&lt;meta name=&quot;keyword&quot; content=&quot;vue,ssr&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;vue srr demo&quot;&gt;` } renderer.renderToString(app, context, (err, html) =&gt; { if (err) { console.log('err',err) res.status(500).end('Internal Server Error') return } res.setHeader(&quot;Content-type&quot;, &quot;text/html;charset=utf8&quot;); res.end(html) })})server.listen(8080) 编写通用代码因为我们的程序是要同时运行在客户端和服务端上的，所以要做好区分，因为有些全局变量只能在服务端或者客户端使用，如window、document只能在客户端使用。因此我们可以创建两个不同的js文件，分别处理不同端的情况。通过webpack打包vue应用程序提供给客户端，由于一些webpack的特定功能不能在服务端运行，如css-loader导入css，所以我们要分开打包，服务端打包生成的bundle用于服务端渲染，客户端bundle用于混合静态标记，也就是激活客户端，之后会讲到，大致的流程如下图： 首先创建通用的app.js文件 在里面导出一个可以重复执行的工厂函数，该函数返回通用的vue实例，为什么要导出一个工厂函数而不是直接导出一个vue实例呢？我们以前在浏览器上使用vue基本都是直接用一个vue实例，但是现在是在服务端运行，每次请求都会获取一次vue，这样vue实例会在各个请求中被共享，容易造成交叉请求污染，所有要导出一个工厂函数，包括之后的vue-router。vuex也是如此。 123456789const Vue = require('vue');module.exports = function createApp(context) { return new Vue({ data: { url: context.url }, template: `&lt;div&gt;访问的URL是：{{ url }}&lt;/div&gt;` })} 创建客户端入口 新建文件entry.client.js,客户端 entry 只需创建应用程序，并且将其挂载到 DOM 中： 123import { createApp } from './app';const { app } = createApp();app.$mount('#app') 创建服务端入口 新建文件entry-server.js，服务端入口导出一个函数，每次渲染都会重复调用此函数，之后我们将在此做服务端路由匹配和数据预取逻辑。 1234import { createApp } from './app';export default context =&gt; { const { app } = createApp()} 路由与代码分割 使用 vue-router 的路由 我们之前的服务器代码匹配路由是用一个*号，也就是所有url都会匹配到，现在我们用vue-router处理访问的url，对客户端和服务器复用相同的路由配置！ (1) 创建router.js 新建router.js,并在写入代码，然后更新app.js 12345678910//router.jsimport Vue from 'vue';import Router from 'vue-router';Vue.use(Router);export function createRouter() { return new Router({ mode: 'history', routes: [] })} 1234567891011121314app.jsimport Vue from 'vue'import { createRouter } from './router'// 导出一个工厂函数，用于创建新的export function createApp () { const router = createRouter() const app = new Vue({ // 根实例简单的渲染应用程序组件。 router, render: h =&gt; h(App), }) return { app, router }} (2) 处理服务端与客户端入口文件 我们先对entry.server.js文件加入对路由逻辑的处理，目的是根据url匹配路由，因为有可能是异步路由，如路由懒加载，所以需要使用onReady等待异步路由加载完成。 12345678910111213141516171819import { createApp } from './app'export default context =&gt; { //因为有可能会是异步路由钩子函数或组件，所以我们将返回一个Promise, //以便服务器能够等待所有的内容在渲染前， //就已经准备就绪。 return new Promise((resolve, reject) =&gt; { const { app, router } = createApp() //设置服窝器端router的位置 router.push(context.url) //等到router将可能的异步组件和钩子函数解析完 router.onReady(() =&gt; { const matchedComponents = router.getMatchedComponents() //匹配不到的路由，执行reject函数，并返回404 if (!matchedComponents.length) return reject({ code: 404 }) // Promise应该resolve应用程序头例，以便匕可以渲染 resolve(app) }, reject) ))) 然后我们对客户端入口文件进行处理 需要注意的是，你仍然需要在挂载 app 之前调用 router.onReady，因为路由器必须要提前解析路由配置中的异步组件，才能正确地调用组件中可能存在的路由钩子。这一步我们已经在我们的服务器入口 (server entry) 中实现过了，现在我们只需要更新客户端入口 (client entry)： 12345import { createApp } from './app'|const { app, router } = createApp()router.onReady(() =&gt; { app.$mount('#app'))) 数据预取存储容器在服务器端渲染(SSR)期间，所以如果应用程序依赖于一些异步数据，那么在开始渲染过程之前，需要先预取和解析好这些数据。因为客户端和服务端需要获取到完全相同的数据，所以我们可以使用vuex进行数据的存取来保证数据的一致性。 创建store.js文件 创建store.js文件并写入代码，具体的逻辑可以忽略，我们只要知道主要的作用是保证数据的一致性，记得在app.js中也要修改，可以导出store，如下： 123456789101112131415161718192021222324252627import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)//假定我们有一个可以返回Promise的//通用API (请忽略此API具体实现细节)import { fetchitem } from './api'export function createStore () { return new Vuex.Store({ state: { items: {} }, actions: { fetchitem ({ commit }, id) { // ' store.dispatch()' 会返回 Promise, //以便我们能够知道数据在何时更新 return fetchltem(id).then(item =&gt; { commit('setitem', { id, item }) }) ) }, mutations: { setitem (state, { id, item }) { Vue.set(state.items, id, item) } } })) 123456789101112131415161718import { createRouter } from './router'import { createStore } from './store'import { sync } from 'vuex-router-sync'export function createApp () { //创建router和store实例 const router = createRouter() const store = createStore() //同步路由状态(route state)到store sync(store, router) //创建应用程序实例，将router和store注入 const app = new Vue({ router, store, render: h =&gt; h(App) }) // 暴露 app, router 和 storeo return { app, router, store }) 界面与数据 现在我们具备渲染页面的条件，但是根据业务需求，我们可以分为以下两种方式： 等待数据加载完成再跳转页面 这种方式是当我们切换页面时，会先等待下一个页面的数据加载完成后，才跳转，具体的实现方式是改造客户端入口文件，使用路由钩子函数beforeResolve，获取到即将跳转的路由组件信息，然后等待组件中的asyncData执行完成后再跳转，如下： 1234567891011121314151617router.onReady(() =&gt; {//添加路由钩子函数，用于处理asyncData.//使用' router.beforeResolve()',以便确保所有异步组件都. resolve。 router.beforeResolve((to, from, next) =&gt; { const matched = router.getMatchedComponents(to) //这里如果有加载指示器(loading indicator),就触发 Promise.all(matched.map(c =&gt; { if (c.asyncData) { return c.asyncData({ store, route: to )) } })).then(() =&gt; £ //停止加载指示器(loading indicator) next() }).catch(next) )) app.$mount('#app')}) 先跳转页面再进行数据处理 这种方式和就比较常见了，和我们平时开发差不多，进入下一个页面后请求相关数据，渲染页面。具体实现是定义一个全局的mixin ，当组件中有asyncData函数时执行，并将其返回的promise赋值，以便之后使用。如下： 1234567891011121314Vue.mixin(( beforeMount () { const { asyncData } = this.$options if (asyncData) { //将获取数据操作分配给promise //以便在组件中，我们可以在数据准备就绪后 //通过运行'this.dataPromise.then(...来执行其他任务 this.dataPromise = asyncData({ store: this.$store, route: this.$route )) } })) 客户端激活所谓客户端激活，指的是 Vue 在浏览器端接管由服务端发送的静态 HTML，使其变为由 Vue 管理的动态 DOM 的过程。由于服务器已经渲染好了 HTML，我们显然无需将其丢弃再重新创建所有的 DOM 元素。相反，我们需要”激活”这些静态的 HTML，然后使他们成为动态的（能够响应后续的数据变化）。 如果你检查服务器渲染的输出结果，你会注意到应用程序的根元素上添加了一个特殊的属性： 1&lt;div id=&quot;app&quot; data-server-rendered=&quot;true&quot;&gt; data-server-rendered 特殊属性，让客户端 Vue 知道这部分 HTML 是由 Vue 在服务端渲染的，并且应该以激活模式进行挂载。注意，这里并没有添加 id=”app”，而是添加 data-server-rendered 属性：你需要自行添加 ID 或其他能够选取到应用程序根元素的选择器，否则应用程序将无法正常激活。注意，在没有 data-server-rendered 属性的元素上，还可以向 $mount 函数的 hydrating 参数位置传入 true，来强制使用激活模式(hydration)： 1app.$mount('#app', &lt;font color=#a862ea&gt;true)&lt;/font&gt; 构建配置在完成两个入口的配置后，接下来就开始用webpack搭建基础框架了。服务器端渲染 (SSR) 项目的配置大体上与纯客户端项目类似，但是我们建议将配置分为三个文件：base, client 和 server。基本配置 (base config) 包含在两个环境共享的配置，例如，输出路径 (output path)，别名 (alias) 和 loader。服务器配置 (server config) 和客户端配置 (client config)，可以通过使用 webpack-merge 来简单地扩展基本配置。 webpack.base.config.js文件 这是一个基础的webpack配置文件，服务端和客户端配置文件会通过webpack-merge插件来合并这个基础配置。 具体的配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374const VueLoaderPlugin = require('vue-loader/lib/plugin')const path = require('path')const resolve = file =&gt; path.resolve(__dirname, file)// CSS 提取应该只用于生产环境// 这样我们在开发过程中仍然可以热重载const isProduction = process.env.NODE_ENV === 'production'let config = { //启用webpack内置的优化,有'production'和'development'两个选项，将会添加不同的plugin，具体看webpack4官方文档 mode: isProduction ? 'production' : 'development', //选择一种source map格式来增强调试过程。一般生产环境下不使用 devtool: isProduction ? false : 'cheap-module-source-map', //打包后输出相关的配置，只能有一个 output: { path: resolve('../dist'), //生成的目录，对应一个绝对路径。 publicPath: '/dist/', //应用程序中所有资源的基础路径。 filename: '[name].[hash].js' //生成文件的名字 }, //配置模块如何解析 resolve: { //创建别名 alias: { 'public': resolve('../public'), 'components': resolve('../src/components'), 'view': resolve('../src/view'), 'request': resolve('../src/request'), 'utils': resolve('../src/utils/') } }, //模块，处理项目中不同的模块类型 module: { //创建模块时，匹配请求的规则数组 rules: [{ test: /\\.js$/, //匹配的文件 exclude: /node_modules/, //排除的目录 loader: &quot;babel-loader&quot; //使用的loader }, { test: /\\.vue$/, loader: 'vue-loader', options: { // hotReload: false // 关闭热重载 } }, { test: /\\.(jpe?g|png|gif|svg)$/, use: { loader: 'url-loader', options: { //url-loader相关配置 outputPath: 'assets/img', //输出图片的地址，相对于output.path publicPath: '../dist/assets/img', //图片的服务地址 limit: 3000, //文件大小低于limit时将图片打包在js中，生成base64 esModule: false, // 这里设置为false，显示图片地址 name: '[name].[ext]?[hash]', //生成图片的名字 } } }, { test: /\\.(woff|svg|eot|ttf)$/, use: { loader: 'url-loader', options: { outputPath: &quot;assets/iconfont&quot;, name: 'iconfont.[name].[ext]?[hash]' } } } ] }, plugins: [ new VueLoaderPlugin() //使用vue-loader必须添加到plugins里 ]}module.exports = config 期间需要安装一些插件，如vue-loader，babel-loader，url-loader来分别处理vue文件，js文件和一些图片及字体图标文件。 webpack.client.config.js文件 这是一个处理客户端入口的webpack配置文件，在这个文件需要引入一个比较关键的插件vue-server-renderer/client-plugin，其实就是我们之前渲染模板的插件下的一个js文件，用于处理入口文件并生成vue-ssr-client-manifest.json文件，之后会引入到node的server文件中。 具体配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const webpack = require('webpack')const MiniCssExtractPlugin = require('mini-css-extract-plugin')const { merge} = require('webpack-merge')const baseConfig = require('./webpack.base.config.js')const VueSSRClientPlugin = require('vue-server-renderer/client-plugin')const isProduction = process.env.NODE_ENV === 'production'let config = merge(baseConfig, { entry: { app: '/src/entry-client.js' }, optimization: { splitChunks: { chunks: 'initial', minSize: 30000, maxSize: 0, minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, automaticNameDelimiter: '~', name: '', cacheGroups: { vendor: { test: /[\\\\/]node_modules[\\\\/]/, chunks: &quot;all&quot;, priority: 10, enforce: true }, commons: { chunks: &quot;all&quot;, minChunks: 2, maxInitialRequests: 5, // minSize: 0, priority: 0 } }, }, runtimeChunk: { name: &quot;manifest&quot; } }, module: { rules: [{ test: /\\.(css|less)$/, use: [isProduction ? MiniCssExtractPlugin.loader : 'vue-style-loader', 'css-loader', 'postcss-loader', 'less-loader' ] }] }, plugins: [ new VueSSRClientPlugin(), new webpack.DefinePlugin({ 'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'development'), 'process.env.VUE_ENV': &quot;'client'&quot; }) ]})if (isProduction) { config.plugins.push(new MiniCssExtractPlugin({ filename: 'common.[chunkhash].css'//css文件名字 }))}module.exports = config 在这里也会随便做一些打包优化，由于使用的webpack版本是4.x，所以js打包优化使用optimization下的splitChunks配置，3.x之前是使用CommonsChunkPlugin插件进行分包，css文件抽离也从extract-text-webpack-plugin插件换成extract-text-webpack-plugin插件。 webpack.server.config.js文件 server的配置文件则主要用到vue-server-renderer插件下的sever-plugin文件，用于生成服务端的vue-ssr-server-bundle.json文件，之后也会在node的server文件中使用。需要注意的点：由于我们使用mini-css-extract-plugin插件进行css文件抽离，但是这个插件在服务端使用会报错，因为使用到了document 等客户端的全局参数，所有我们在处理css文件时需要分成服务端和客户端两个loader处理。还有就是使用vue-style-loader代替style-loader，因为vue-style-loader多了些对服务端渲染的处理： 客户端和服务器端的通用编程体验。 在使用 bundleRenderer 时，自动注入关键 CSS(critical CSS)。 通用 CSS 提取。 12345678910111213141516171819202122232425262728293031323334353637const webpack = require('webpack')const { merge} = require('webpack-merge')const nodeExternals = require('webpack-node-externals')const baseConfig = require('./webpack.base.config.js')const VueSSRServerPlugin = require('vue-server-renderer/server-plugin')module.exports = merge(baseConfig, { entry: '/src/entry-server.js', target: 'node', devtool: 'source-map', output: { libraryTarget: 'commonjs2' }, externals: nodeExternals({ allowlist: [/\\.css$/] }), module: { rules: [{ test: /\\.(css|less)$/, use: ['vue-style-loader', 'css-loader', 'postcss-loader', 'less-loader' ] }, ] }, plugins: [ new VueSSRServerPlugin(), new webpack.DefinePlugin({ 'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'development'), 'process.env.VUE_ENV': &quot;'server'&quot; }), ]}) 配置开发环境因为现在这个脚手架如果代码有改动，每次都需要重新build一遍，然后再start，开发起来比较麻烦，所有我们要配置下开发环境，使用热重载。 setup-dev-server.js文件 在build文件夹下新建一个setup-dev-server.js，当做开发环境的配置文件，在这个文件里需要引入服务端和客户端的两个配置文件，然后安装webpack-dev-middleware和webpack-hot-middleware来使用热重载，监听文件变化然后触发热重载。 完整的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107const fs = require('fs')const path = require('path')const MFS = require('memory-fs')//操作内存的文件系统const webpack = require('webpack')const chokidar = require('chokidar')//封装 Node.js 监控文件系统文件变化功能的库const clientConfig = require('./webpack.client.config')const serverConfig = require('./webpack.server.config')const mfs = new MFS()const writeRouter = require('../fs/index')const renderRouter = process.env.RENDER_ROUTER === 'true'//是否执行动态路由表const readFile = (fs, file) =&gt; { try { return fs.readFileSync(path.join(clientConfig.output.path, file), 'utf-8') } catch (e) {}}let isFirstRender = true //判断是否是第一次渲染，由于chokidar监听add事件第一次会监听所有文件的新增，所有需要排除掉第一次module.exports = function setupDevServer (app, templatePath, cb) { let bundle let template let clientManifest let ready const readyPromise = new Promise(r =&gt; { ready = r }) const update = () =&gt; { if (bundle &amp;&amp; clientManifest) {//文件更新后且两个文件存在时resolve，并执行回调 ready() isFirstRender = false cb(bundle, { template, clientManifest }) } } // read template from disk and watch template = fs.readFileSync(templatePath, 'utf-8') chokidar.watch(templatePath).on('change', () =&gt; {//监听模板变化 template = fs.readFileSync(templatePath, 'utf-8') console.log('index.html template updated.') update() }) chokidar.watch(path.resolve(__dirname,'../src/view')).on('add', () =&gt; {//监听view文件下的新增 if(!isFirstRender) { renderRouter &amp;&amp; writeRouter()//路由写入方法 update() } }) chokidar.watch(path.resolve(__dirname,'../src/view')).on('unlink', () =&gt; {//监听view文件下的删除 if(!isFirstRender) { renderRouter &amp;&amp; writeRouter()//路由写入方法 update() } }) /** * https://github.com/webpack-contrib/webpack-hot-middleware * 添加热重载及相关参数 noInfo：不输出相关信息 reload：自动更新 */ clientConfig.entry.app = ['webpack-hot-middleware/client?noInfo=true&amp;reload=true', clientConfig.entry.app] clientConfig.output.filename = '[name].js' clientConfig.plugins.push( // new webpack.optimize.OccurrenceOrderPlugin(),//webpack 1.x new webpack.HotModuleReplacementPlugin(),//启用热重载 // new webpack.NoEmitOnErrorsPlugin()//webpack 1.x ) // dev middleware const clientCompiler = webpack(clientConfig) /** * 使用该插件修改文件时无需重新编译，一般配合webpack-hot-middleware实现热重载 * https://www.npmjs.com/package/webpack-dev-middleware */ const devMiddleware = require('webpack-dev-middleware')(clientCompiler, { publicPath: clientConfig.output.publicPath,//绑定中间件的公共路径,与webpack配置的路径相同 // quiet: true,//向控制台显示任何内容 noInfo: true//显示无信息到控制台（仅警告和错误） }) //使用webpack-dev-middleware中间件 app.use(devMiddleware) clientCompiler.plugin('done', stats =&gt; {//在成功构建并且输出了文件后，Webpack 即将退出时发生； stats = stats.toJson() stats.errors.forEach(err =&gt; console.error(err)) stats.warnings.forEach(err =&gt; console.warn(err)) if (stats.errors.length) return clientManifest = JSON.parse(readFile( devMiddleware.fileSystem, 'vue-ssr-client-manifest.json' )) update() }) //使用热重载中间件 app.use(require('webpack-hot-middleware')(clientCompiler)) const serverCompiler = webpack(serverConfig) serverCompiler.outputFileSystem = mfs //将serverCompiler的文件系统改成内存系统 serverCompiler.watch({}, (err, stats) =&gt; {//当文件发生改变时执行 if (err) throw err stats = stats.toJson() if (stats.errors.length) return // read bundle generated by vue-ssr-webpack-plugin bundle = JSON.parse(readFile(mfs, 'vue-ssr-server-bundle.json')) update() }) return readyPromise} 修改server文件 我们需要对server文件进行修改，判断正式环境和测试环境，分别执行不同的方法，当前是测试环境时，执行setup-dev-server导出的setupDevServer方法，该方法返回一个promise，在服务端和客户端文件重新构建完成后resolve，之后再触发render方法，执行renderToString方法返回html给客户端，从而实现开发环境热重载。 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102const express = require('express')const app = express()const favicon = require('serve-favicon')//网页图标const path = require('path')const writeRouter = require('../fs/index')/** * 服务端渲染的关键 * https://ssr.vuejs.org/zh/api/ */const { createBundleRenderer } = require('vue-server-renderer')const resolve = file =&gt; path.resolve(__dirname, file)const templatePath = resolve('../src/index.template.html')const serverInfo = `express/${require('express/package.json').version} ` + `vue-server-renderer/${require('vue-server-renderer/package.json').version}`const isProd = process.env.NODE_ENV === 'production'//判断是否是生成环境const renderRouter = process.env.RENDER_ROUTER === 'true'//是否执行动态路由表renderRouter &amp;&amp; writeRouter()//路由写入方法//静态目录配置const serve = (path, cache) =&gt; express.static(resolve(path), { maxAge: cache &amp;&amp; isProd ? 1000 * 60 * 60 * 24 * 30 : 0})let readyPromise,rendererif(isProd) { const template = require('fs').readFileSync(templatePath, 'utf-8') const serverBundle = require(resolve('../dist/vue-ssr-server-bundle.json')) const clientManifest = require(resolve('../dist/vue-ssr-client-manifest.json')) /** * 第一个参数可以是以下之一： * 绝对路径，指向一个已经构建好的 bundle 文件（.js 或 .json）。必须以 / 开头才会被识别为文件路径。 * webpack + vue-server-renderer/server-plugin 生成的 bundle 对象。 * JavaScript 代码字符串（不推荐）。 */ renderer = createRenderer(serverBundle, { runInNewContext: false,//bundle 代码将与服务器进程在同一个 global 上下文中运行，所以请留意在应用程序代码中尽量避免修改 global。 template,//模板 clientManifest//由 vue-server-renderer/client-plugin 生成的客户端构建 manifest 对象 })} else { readyPromise = require(resolve('../build/setup-dev-server'))( app, templatePath, (bundle, options) =&gt; { renderer = createRenderer(bundle, options) } )}function createRenderer (bundle, options) { // https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer return createBundleRenderer(bundle, options)}function render (req, res) { const s = Date.now() res.setHeader(&quot;Content-Type&quot;, &quot;text/html&quot;) res.setHeader(&quot;Server&quot;, serverInfo) const handleError = err =&gt; { if (err.url) { res.redirect(err.url) } else if(err.code === 404) { res.status(404).send('404 | Page Not Found') } else { // Render Error Page or Redirect res.status(500).send('500 | Internal Server Error') console.error(`error during render : ${req.url}`) console.error(err.stack) } } const context = { title: 'Vue ssr', // default title url: req.url } /** * renderToString将context传递给entry-server， * vue实例挂载的内容变成html，返回给客户端 */ renderer.renderToString(context, (err, html) =&gt; { if (err) { return handleError(err) } res.send(html) if (!isProd) { console.log(`whole request: ${Date.now() - s}ms`) } })}app.use('/dist', serve('../dist', true)) //访问/dist时访问dist目录下的文件app.use(favicon(resolve('../public/img/logo-48.png')))app.get('*', isProd ? render : (req, res) =&gt; { readyPromise.then(() =&gt; render(req, res))})app.listen(8080, () =&gt; { console.log(`server started at localhost: 8080`)}) 配置启动参数在项目根目录package.json中的srcipt参数中增加如下参数： 123456789&quot;scripts&quot;: { &quot;dev&quot;: &quot;cross-env RENDER_ROUTER=false node server/index&quot;, &quot;start&quot;: &quot;cross-env NODE_ENV=production node server/index&quot;, &quot;build&quot;: &quot;rimraf dist &amp;&amp; npm run build:client &amp;&amp; npm run build:server&quot;, &quot;build:renderRouter&quot;: &quot;cross-env FIRST_RENDER=true node fs/index &amp;&amp; rimraf dist &amp;&amp; npm run build:client &amp;&amp; npm run build:server&quot;, &quot;build:client&quot;: &quot;cross-env NODE_ENV=production webpack --config build/webpack.client.config.js --progress&quot;, &quot;build:server&quot;: &quot;cross-env NODE_ENV=production webpack --config build/webpack.server.config.js --progress&quot;, &quot;build:analyzer&quot;: &quot;cross-env NODE_ENV=production ANALYZER=true webpack --config build/webpack.client.config.js --progress&quot; }, dev 启动开发环境，运行系统 start 该命令传入一个参数NODE_ENV=production来设置node环境变量，在node进程中的文件使用process.env.production可以访问该参数的值，用于判断当前环境。然后执行node server启动。不过在前提下需要先执行npm run build命令，打包生成服务端和客户端的json文件，才可以启动。 build 该命令先移除dist文件夹下的所有文件，然后再执行客户端和服务端文件的打包 其他 其他命令都是些优化和分析相关 总结该文章介绍了服务端渲染的优势及vue服务端渲染（SSR）的方案，因为我们现在前端开发大多数接触的都是客户端渲染，往往忽略了一些其他的方案，如服务端渲染（SSR）和静态网站渲染（SSG）。通过这次分享可以了解vue服务端渲染的两个基本实现方法，nuxt.js和脚手架搭建，其中nuxt.js功能更加全面，开发成本低，不过可定制性较差，而自己搭建脚手架开发成本会高很多，但是可以根据自己的需求定制。对于已经开发完成的项目推荐在当前开发框架上修改，而对于新开发的项目，使用nuxt.js可能是最好的方式。","link":"/2021/04/09/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/vue/vue_ssr/"},{"title":"typeScript语法学习","text":"对应demots语法学习","link":"/2021/04/22/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/typeScript/typeScript/"},{"title":"webpack5模块联邦","text":"demo 介绍官网多个独立的构建可以组成一个应用程序，这些独立的构建之间不应该存在依赖关系，因此可以单独开发和部署它们。这通常被称作微前端，但并不仅限于此。简单来说就是可以实现不同环境下的组件数据互通。 webpack5模块联邦测试appA 子容器123456789101112131415161718192021222324//appA/build/webpack.config.jsconst path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const ModuleFederationPlugin = require(&quot;webpack/lib/container/ModuleFederationPlugin&quot;);module.exports = { mode: 'production', entry: path.resolve(__dirname, '../src/index.js'), output: { filename: 'bundle.js', path: path.resolve(__dirname, '../dist'), }, plugins: [ new HtmlWebpackPlugin(), new ModuleFederationPlugin({ name: 'appA', library: { type: &quot;var&quot;, name: &quot;appA&quot; }, filename: 'appA.js', exposes: { './Button': &quot;./src/component/buttton&quot; } }) ],}; appB 父容器12345678910111213141516171819202122//appB/build/webpack.config.jsconst path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const ModuleFederationPlugin = require(&quot;webpack/lib/container/ModuleFederationPlugin&quot;);module.exports = { mode: 'production', entry: path.resolve(__dirname, '../src/index.js'), output: { filename: 'bundle.js', path: path.resolve(__dirname, '../dist'), }, plugins: [ new HtmlWebpackPlugin(), new ModuleFederationPlugin({ name: 'appB', remotes: { appA: &quot;appA@http://127.0.0.1:5500/appA/dist/appA.js&quot;, }, }) ],}; appB B中引用了A的button组件","link":"/2021/12/28/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/webpack/moduleFederation/"},{"title":"webpack5搭建vue3","text":"demo 开始初始化 npm init创建package.json 然后安装webpack相关插件 1npm i webpack webpack-cli --save-dev 创建build文件夹并新建webpack配置文件 12345678910111213141516171819202122const path = require('path');function resolvePath(filePath) { return path.resolve(__dirname, filePath);}module.exports = { mode: 'production', entry: resolvePath('../src/main.js'), output: { path: resolvePath('../dist'), filename: '[contenthash].bundle.js', }, module: { rules: [], }, plugins: [ new webpack.DefinePlugin({ BASE_URL: '&quot;../public/&quot;' }) ],}; 安装vue相关依赖 安装vue相关依赖 123npm i vue -S //-S 等于 --save -D 等于 --save-dev i 等于 installnpm i vue-loader -D //解析和转换.vue文件。提取出其中的逻辑代码 script,样式代码style,以及HTML 模板template，再分别把他们交给对应的loader去处理 npm i @vue/compiler-sfc -D //将解析完的vue单页面组件(sfc)编译为js 配置vue-loader 12345678910111213//webpack.config.jsconst { VueLoaderPlugin } = require('vue-loader');module: { rules: [ { test: /\\.vue$/, loader: 'vue-loader', }, ];}plugins: [ new VueLoaderPlugin(),] 创建main.js文件 123import { createApp } from 'vue'import App from './App.vue' // 测试文件 App.vue 和 用于挂载的index.html 自行创建createApp(App).mount('#app') 安装css，sass相关依赖 安装 1npm i css-loader style-loader sass sass-loader -D 配置loader 123456789101112module: { { test: /\\.(sa)|css$/, use: [{ loader: 'style-loader' }, { loader: 'css-loader' }, { loader: 'sass-loader' }] }],}, 使用模板 安装 1npm i html-webpack-plugin -D //在打包结束后，自动生成一个html文件，并把打包生成的js文件引入到这个html文件当中 配置plugins 1234567891011const HtmlWebpackPlugin = require('html-webpack-plugin'); plugins: [ new webpack.DefinePlugin({ BASE_URL: '&quot;./&quot;' }), new HtmlWebpackPlugin({ title: 'vue3-app', filename: 'index.html', template: resolvePath('../public/index.html'), }),], 创建index.html 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; &lt;strong&gt;We're sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn't work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt; &lt;/noscript&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt; 自动删除文件 安装 1npm i clean-webpack-plugin -D //在打包之前清空output配置的文件夹 配置 1234const { CleanWebpackPlugin } = require('clean-webpack-plugin');plugins: [ new CleanWebpackPlugin()] 拷贝文件1npm i copy-webpack-plugin --save-dev 1234567891011const CopyWebpackPlugin = require('copy-webpack-plugin'); plugins: [ new CopyWebpackPlugin({ patterns: [ { from: resolvePath('../public/favicon.ico'), to: resolvePath('../dist/favicon.ico'), } ] }) ], 搭建开发环境拷贝一份webpack.config.js文件，命名为webpack.config.dev.js，删除拷贝插件相关的代码 安装 1npm i webpack-dev-server -D //以file形式在浏览器打开打包后的文件，无法发送ajax请求。所以需要devServer在本地开启一个服务器，以http的形式发送请求。 配置 123456789devServer: { static: { directory: resolvePath('../public'), }, open: true, hot: true, compress: true, port: 9000,}, 优化效率工具 progress-bar-webpack-plugin：查看编译进度； speed-measure-webpack-plugin：查看编译速度； webpack-bundle-analyzer：打包体积分析。 加快构建速度更新webpack版本为5缓存cache通过配置 webpack 持久化缓存 cache: filesystem，来缓存生成的 webpack 模块和 chunk，改善构建速度。 简单来说，通过 cache: filesystem 可以将构建过程的 webpack 模板进行缓存，大幅提升二次构建速度、打包速度，当构建突然中断，二次进行构建时，可以直接从缓存中拉取，可提速 90% 左右。 配置如下： 12345module.exports = { cache: { type: &quot;filesystem&quot;, // 使用文件缓存 },}; 减少 loader、plugins指定 include为 loader 指定 include，减少 loader 应用范围，仅应用于最少数量的必要模块。 rule.exclude 可以排除模块范围，也可用于减少 loader 应用范围. 管理资源使用 webpack 资源模块 (asset module) 代替旧的 assets loader（如 file-loader/url-loader/raw-loader 等），减少 loader 配置数量。 配置方式如下： 123456789module.exports = { rules: [ { test: /\\.(png|svg|jpg|jpeg|gif)$/i, include: [resolvePath('../src')], type: &quot;asset/resource&quot;, }, ],}; 优化 resolve 配置aliasalias 可以创建 import 或 require 的别名，用来简化模块引入。 配置方式如下： 1234567module.exports = { resolve: { alias: { &quot;@&quot;: resolvePath('../src'), // @ 代表 src 路径 }, },}; extensionsextensions 表示需要解析的文件类型列表。 根据项目中的文件类型，定义 extensions，以覆盖 webpack 默认的 extensions，加快解析速度。 由于 webpack 的解析顺序是从左到右 webpack.common.js 配置方式如下： 12345module.exports = { resolve: { extensions: [&quot;.js&quot;], },}; 多进程thread-loader通过 thread-loader 将耗时的 loader 放在一个独立的 worker 池中运行，加快 loader 构建速度。 安装： 1npm i -D thread-loader webpack.common.js 配置方式如下： 1234567891011121314151617181920212223242526module.exports = { rules: [ { test: /\\.s?css$/, include: resolvePath('../src'), use: [ 'style-loader', NODE_ENV !== 'dev' &amp;&amp; MiniCssExtractPlugin.loader, //分离css { loader: 'css-loader', options: { modules: true, importLoaders: 2, }, }, 'sass-loader', { loader: &quot;thread-loader&quot;, options: { workerParallelJobs: 2, }, } ] }, ],}; 减小打包体积代码压缩JS 压缩使用 TerserWebpackPlugin 来压缩 JavaScript。 webpack5 自带最新的 terser-webpack-plugin，无需手动安装。 1terser-webpack-plugin` 默认开启了 `parallel: true` 配置，并发运行的默认数量： `os.cpus().length - 1 配置方式如下： 1234567891011121314151617181920212223242526272829const TerserPlugin = require(&quot;terser-webpack-plugin&quot;);module.exports = { optimization: { minimizer: [ new TerserPlugin({ parallel: 4, terserOptions: { parse: { ecma: 8, }, compress: { ecma: 5, warnings: false, comparisons: false, inline: 2, }, mangle: { safari10: true, }, output: { ecma: 5, comments: false, ascii_only: true, }, }, }), ], },}; 你可能有听过 ParallelUglifyPlugin 插件，它可以帮助我们多进程压缩 JS，webpack5 的 TerserWebpackPlugin 默认就开启了多进程和缓存，无需再引入 ParallelUglifyPlugin。 CSS 压缩使用 CssMinimizerWebpackPlugin 压缩 CSS 文件。 和 optimize-css-assets-webpack-plugin 相比，css-minimizer-webpack-plugin 在 source maps 和 assets 中使用查询字符串会更加准确，而且支持缓存和并发模式下运行。 CssMinimizerWebpackPlugin 将在 Webpack 构建期间搜索 CSS 文件，优化、压缩 CSS。 安装： 1npm install -D css-minimizer-webpack-plugin 配置方式如下： 1234567891011const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;);module.exports = { optimization: { minimizer: [ new CssMinimizerPlugin({ parallel: 4, }), ], },}; 代码分离代码分离能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，可以缩短页面加载时间。 抽离重复代码SplitChunksPlugin 插件开箱即用，可以将公共的依赖模块提取到已有的入口 chunk 中，或者提取到一个新生成的 chunk。 webpack 将根据以下条件自动拆分 chunks： 新的 chunk 可以被共享，或者模块来自于 node_modules 文件夹； 新的 chunk 体积大于 20kb（在进行 min+gz 之前的体积）； 当按需加载 chunks 时，并行请求的最大数量小于或等于 30； 当加载初始化页面时，并发请求的最大数量小于或等于 30；通过 splitChunks 把 react 等公共库抽离出来，不重复引入占用体积。 配置方式如下： 1234567891011121314151617module.exports = { splitChunks: { // include all types of chunks chunks: &quot;all&quot;, // 重复打包问题 cacheGroups: { vendors: { // node_modules里的代码 test: /[\\\\/]node_modules[\\\\/]/, chunks: &quot;all&quot;, // name: 'vendors', 一定不要定义固定的name priority: 10, // 优先级 enforce: true, }, }, },}; CSS 文件分离MiniCssExtractPlugin 插件将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件，并且支持 CSS 和 SourceMaps 的按需加载。 安装： 1npm install -D mini-css-extract-plugin 1234567891011121314151617181920212223242526module.exports = { rules: [ { test: /\\.s?css$/, include: resolvePath('../src'), use: [ 'style-loader', NODE_ENV !== 'dev' &amp;&amp; MiniCssExtractPlugin.loader, //分离css { loader: 'css-loader', options: { modules: true, importLoaders: 2, }, }, 'sass-loader', { loader: &quot;thread-loader&quot;, options: { workerParallelJobs: 2, }, } ] }, ],}; 注意：MiniCssExtractPlugin.loader 要放在 style-loader 后面。 最小化 entry chunk通过配置 optimization.runtimeChunk = true，为运行时代码创建一个额外的 chunk，减少 entry chunk 体积，提高性能。 配置方式如下： 123456module.exports = { optimization: { runtimeChunk: true, }, };} Tree Shaking摇树，顾名思义，就是将枯黄的落叶摇下来，只留下树上活的叶子。枯黄的落叶代表项目中未引用的无用代码，活的树叶代表项目中实际用到的源码。 JSJS Tree Shaking 将 JavaScript 上下文中的未引用代码（Dead Code）移除，通过 package.json 的 &quot;sideEffects&quot; 属性作为标记，向 compiler 提供提示，表明项目中的哪些文件是 “pure(纯正 ES2015 模块)”，由此可以安全地删除文件中未使用的部分。 Dead Code 一般具有以下几个特征： 代码不会被执行，不可到达； 代码执行的结果不会被用到； 代码只会影响死变量（只写不读）。 webpack5 sideEffects通过 package.json 的 &quot;sideEffects&quot; 属性，来实现这种方式。 1234{ &quot;name&quot;: &quot;your-project&quot;, &quot;sideEffects&quot;: false} 需注意的是，当代码有副作用时，需要将 sideEffects 改为提供一个数组，添加有副作用代码的文件路径： 1234{ &quot;name&quot;: &quot;your-project&quot;, &quot;sideEffects&quot;: [&quot;./src/some-side-effectful-file.js&quot;]} CSS上述对 JS 代码做了 Tree Shaking 操作，同样，CSS 代码也需要摇摇树，打包时把没有用的 CSS 代码摇走，可以大幅减少打包后的 CSS 文件大小。 使用 purgecss-webpack-plugin 对 CSS Tree Shaking。 安装： 1npm i purgecss-webpack-plugin -D 因为打包时 CSS 默认放在 JS 文件内，因此要结合 webpack 分离 CSS 文件插件 mini-css-extract-plugin 一起使用，先将 CSS 文件分离，再进行 CSS Tree Shaking。 webpack.prod.js 配置方式如下： 123456789101112const glob = require(&quot;glob&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);const PurgeCSSPlugin = require(&quot;purgecss-webpack-plugin&quot;);module.exports = { plugins: [ // CSS Tree Shaking new PurgeCSSPlugin({ paths: glob.sync(`${resolvePath('../src')}/**/*`, { nodir: true }), }), ],}; 上面为了测试 CSS 压缩效果，我引入了大量无效 CSS 代码，因此 Tree Shaking 效果也非常明显。","link":"/2022/01/10/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/webpack/webpack5_vue3/"},{"title":"qiankun的基本使用","text":"qiankun 是一个基于 single-spa 的微前端实现库，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。 详细请看官网。 特性 📦 基于 single-spa 封装，提供了更加开箱即用的 API。 📱 技术栈无关，任意技术栈的应用均可 使用/接入，不论是 React/Vue/Angular/JQuery 还是其他等框架。 💪 HTML Entry 接入方式，让你接入微应用像使用 iframe 一样简单。 🛡 样式隔离，确保微应用之间样式互相不干扰。 🧳 JS 沙箱，确保微应用之间 全局变量/事件 不冲突。 ⚡️ 资源预加载，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度。 🔌 umi 插件，提供了 @umijs/plugin-qiankun 供 umi 应用一键切换成微前端架构系统。 使用qiankun应用分成主应用和微应用，通过主应用可以控制微应用及主微应用之间的数据传递。 本项目主应用是vite搭建的vue3，微应用是react和vue2。 安装1yarn add qiankun # 或者 npm i qiankun -S 在主应用中注册微应用 在main.ts中注册微应用 123456789101112131415import { registerMicroApps, start } from 'qiankun';registerMicroApps([ { name: 'reactApp', // app name registered entry: '//localhost:4000', container: '#reactApp', activeRule: '/reactApp', }, { name: 'vueApp', entry: '//localhost:8080', container: '#vueApp', activeRule: '/vueApp', },]); 在路由文件router/index.ts中注册路由，可以通过路由控制不同微应用的显示。记得微应用相关的路由都要注册，不过可以指向同一个组件。 1234567891011121314151617181920212223242526272829303132333435363738394041import { createRouter, createWebHistory } from &quot;vue-router&quot;;const routes = [ //vue微应用 { path: '/vueApp', name: 'vueApp-home', component: () =&gt; import(&quot;@/view/vueApp/index.vue&quot;) }, { path: '/vueApp/about', name: 'vueApp-about', component: () =&gt; import(&quot;@/view/vueApp/index.vue&quot;) }, //react微应用 { path: '/reactApp', name: 'reactApp-home', component: () =&gt; import(&quot;@/view/reactApp/index.vue&quot;) }, { path: '/reactApp/list', name: 'reactApp-list', component: () =&gt; import(&quot;@/view/reactApp/index.vue&quot;) }, { path: '/reactApp/collection', name: 'reactApp-collection', component: () =&gt; import(&quot;@/view/reactApp/index.vue&quot;) }, { path: '/reactApp/detail/:id', name: 'reactApp-detail', component: () =&gt; import(&quot;@/view/reactApp/index.vue&quot;) },]export default createRouter({ history: createWebHistory(), routes}); 新建两个组件分别代表不同微应用。记得id要对应container。然后再其中调用start方法可以启动微应用。 以下是react的微应用vue文件，vue的也是类似。 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div id=&quot;reactApp&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import { onMounted } from &quot;vue&quot;;import { registerMicroApps, start } from &quot;qiankun&quot;;let qiankunStarted = false;export default { setup() { onMounted(() =&gt; { if (!qiankunStarted) { qiankunStarted = true; start(); } }); }};&lt;/script&gt;&lt;style lang='scss' scoped&gt;#vueApp { width: 100%; height: 100%;}&lt;/style&gt; 这样一来主应用的配置就基本完成了。 react微应用可以通过官网的方式创建（推荐）。 以下方式和官网有一点不同，主要就是webpack配置，由于本项目直接通过npm run eject暴露了webpack相关配置，所以直接在其中进行修改。 在 src 目录新增 public-path.js： 123if (window.__POWERED_BY_QIANKUN__) { __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;} 在src/index.tsx中修改。 12345678910111213141516171819202122232425262728293031323334353637383940414243import './public-path';import { createRoot } from 'react-dom/client';import { Provider } from 'react-redux';import configureStore from './store';import './index.scss';import App from './App';import reportWebVitals from './reportWebVitals';import { BrowserRouter } from 'react-router-dom';function render(props: any) { const { container } = props; const rootDom = document.getElementById('root'); const root = createRoot(container ? container.querySelector('#root') : rootDom); root.render( &lt;BrowserRouter basename={window.__POWERED_BY_QIANKUN__ ? '/reactApp' : '/'}&gt; &lt;Provider store={configureStore}&gt; &lt;App /&gt; &lt;/Provider&gt; &lt;/BrowserRouter&gt; ); // If you want to start measuring performance in your app, pass a function // to log results (for example: reportWebVitals(console.log)) // or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals reportWebVitals();}if (!window.__POWERED_BY_QIANKUN__) { render({});}export async function bootstrap() { console.log('[react16] react app bootstraped');}export async function mount(props: any) { console.log('[react16] props from main framework', props); render(props);}export async function unmount(props: any) { const { container } = props; ReactDOM.unmountComponentAtNode(container ? container.querySelector('#root') : document.querySelector('#root'));} 在config/webpack.config.js中修改 1234567891011121314151617const { name} = path.resolve(__dirname, '/package');module.exports = function (webpackEnv) { return { //... output: { //... library: `${name}-[name]`, libraryTarget: 'umd', chunkLoadingGlobal: `webpackJsonp_${name}`, globalObject: 'window', //... }, //... }} 在config/webpackDevServer.config.js中修改 123456789101112module.exports = function (proxy, allowedHost) { return { //... hot: false, historyApiFallback: true, liveReload: false, static: { watch: false } //... }} 基本配置差不多了，其他就是一些兼容，如__POWERED_BY_QIANKUN__变量需要在src/react-app-env.d.ts中声明。还有就是一些路径的适配，如public下的文件由于没有通过webpack打包，所以在代码中使用的时候需要判断路径。 vue微应用vue微应用和react也是类似，修改相关配置，暴露出生命周期钩子。 详细可以看官网。 最终效果 总结以上就是qiankun的基本使用，当然qiankun还有更多用法，比如不通过路由控制（registerMicroApps）微应用，直接手动方式控制（loadMicroApp）等等。","link":"/2022/06/07/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E5%89%8D%E7%AB%AF/qiankun/"},{"title":"springboot部署","text":"Jenkins可使用Docker部署Jenkins，并将创建挂载点将安装的Docker（因为需要在Jenkins容器内使用docker，docker-compose），Maven，Java JDK等（相关的一些依赖也可以统一管理）也一起挂载。可采用Docker Compose进行安装Jenkins，如下： 创建docker-compose.yml1234567891011121314151617version: &quot;3.1&quot;services: jenkins: image: jenkins/jenkins:lts user: root container_name: jenkins ports: - 8080:8080 - 50000:50000 privileged: true volumes: - ./data/:/var/jenkins_home/ - /usr/bin/docker:/usr/bin/docker - /var/run/docker.sock:/var/run/docker.sock - /usr/local/bin/docker-compose:/usr/local/bin/docker-compose - /usr/bin/docker-compose:/usr/bin/docker-compose - /usr/lib/dockerlib:/usr/lib/dockerlib 上传文件到服务器可自由选择目录上传，我是上传到/usr/local/jenkins-docker中 运行在运行之前，可以先拉取jenkins镜像，运行命令docker pull jenkins/jenkins:latest拉取最新的镜像，之后在docker-compose.yml所在目录下运行docker-compose up -d命令，**-d**指在后台运行。 配置JenkinsJenkins需要配置下maven和Java JDK（可选），在系统管理—全局根据配置—Maven配置中配置上传的maven的settings.xml路径，并在Maven安装中新增Maven，路径为Maven安装路径。具体看Maven部分。 创建任务 新建一个任务（自由风格）。 填写Github地址和分支。 新增Build Steps。 选择Maven，并在目标中填写clean install -Dmaven.test.skip=true 选择shell，并写入 12cd /var/jenkins_home/workspace/springboot-demodocker-compose up -d --build 保存后进行构建。 MavenMaven可以安装和管理Springboot依赖，由于我们是通过Docker部署的Jenkins，需要在本地先安装，并修改settings.xml，修改源，加快安装依赖的速度，然后将其挂载到Jenkins容器中。 下载安装 在官网中下载 Maven下载地址 上传到服务器 我将其放在/usr/lib/dockerlib/maven路径中，然后解压 添加源 在config文件夹里的settings.xml中添加： 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt; 挂载Maven 启动Jenkins容器时，将其挂载在Jenkins的容器目录中。 12volumes: - /usr/lib/dockerlib:/usr/lib/dockerlib 在Jenkins中配置 SpringBootSpringboot需对MySql和Redis进行配置，然后新建Dockerfile和docker-compose.yml文件，用于启动docker容器。 12345678910111213141516171819202122232425262728293031323334353637383940414243version: '3.8'services: # MySQL 服务 mysql: image: mysql:5.7 container_name: mysql-container environment: MYSQL_ROOT_PASSWORD: root MYSQL_DATABASE: user_db ports: - &quot;3306:3306&quot; networks: - my-network volumes: - /usr/local/mysql-docker:/var/lib/mysql # Redis 服务 redis: image: redis:latest container_name: redis-container ports: - &quot;6379:6379&quot; networks: - my-network # Spring Boot 应用服务 springboot-app: build: context: . dockerfile: Dockerfile # 指定Dockerfile路径，默认是当前目录下的 Dockerfile container_name: springboot-app ports: - &quot;8081:8081&quot; depends_on: - mysql - redis networks: - my-networknetworks: my-network: driver: bridge 1234567891011121314# 使用官方的 OpenJDK 镜像FROM openjdk:17-jdk-slim# 设置工作目录WORKDIR /app# 将 JAR 文件复制到容器中COPY target/demo-0.0.1-SNAPSHOT.jar /app/demo-0.0.1-SNAPSHOT.jar# 暴露端口EXPOSE 8081# 启动应用ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/app/demo-0.0.1-SNAPSHOT.jar&quot;] 其他注意SSH key如果要在Jenkins配置git ssh公钥，需要在Jenkins容器中切换用户为Jenkins，su jenkins，然后再执行接下来命令： 12345678910111. 检查密钥ls -al ~/.ssh2. 生成密钥ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;3. 将 SSH 密钥添加到 SSH 代理eval &quot;$(ssh-agent -s)&quot;ssh-add ~/.ssh/id_rsa4. 查看密钥，并将密钥配置到githubcat ~/.ssh/id_rsa.pub5. 测试 SSH 连接ssh -T git@github.com 或者直接拷贝服务器中的id_rsa和id_rsa.pub文件到Jenkins容器中，再进行从第三步开始。 12docker cp ~/.ssh/id_rsa jenkins:~/.ssh/id_rsadocker cp ~/.ssh/id_rsa.pub jenkins:~/.ssh/id_rsa.pub 修改 Jenkins 容器内的时区（适用于已运行的容器）如果 Jenkins 容器已经在运行，可以通过以下步骤修改时区： 进入容器： 1docker exec -it jenkins bash 修改时区： 12echo &quot;Asia/Shanghai&quot; &gt; /etc/timezoneln -fs /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 退出并重启容器： 1docker restart jenkins","link":"/2025/02/19/%E5%AD%A6%E4%B9%A0/%E5%90%8E%E7%AB%AF/java/springboot/%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"golang","slug":"golang","link":"/tags/golang/"},{"name":"beego","slug":"beego","link":"/tags/beego/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"jenkins","slug":"jenkins","link":"/tags/jenkins/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"flutter","slug":"flutter","link":"/tags/flutter/"},{"name":"dart","slug":"dart","link":"/tags/dart/"},{"name":"canvas","slug":"canvas","link":"/tags/canvas/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"typeScript","slug":"typeScript","link":"/tags/typeScript/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"three","slug":"three","link":"/tags/three/"},{"name":"项目","slug":"项目","link":"/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"javaScript","slug":"javaScript","link":"/tags/javaScript/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"webRTC","slug":"webRTC","link":"/tags/webRTC/"},{"name":"websoket","slug":"websoket","link":"/tags/websoket/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"electron","slug":"electron","link":"/tags/electron/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"vite","slug":"vite","link":"/tags/vite/"},{"name":"ssr","slug":"ssr","link":"/tags/ssr/"},{"name":"微前端","slug":"微前端","link":"/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"name":"qiankun","slug":"qiankun","link":"/tags/qiankun/"},{"name":"后端","slug":"后端","link":"/tags/%E5%90%8E%E7%AB%AF/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"}],"categories":[{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"后端","slug":"学习/后端","link":"/categories/%E5%AD%A6%E4%B9%A0/%E5%90%8E%E7%AB%AF/"},{"name":"前端","slug":"学习/前端","link":"/categories/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/"}],"pages":[]}