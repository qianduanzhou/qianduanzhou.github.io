---
title: 实时通讯
date: 2023-03-21 15:53:17
cover: /img/thumbnail/学习/前端/webRTC/webRTC.png
thumbnail: /img/thumbnail/学习/前端/webRTC/webRTC.png
toc: true
tags: 
- react
- webRTC
- websoket
- 项目
---

这是一个可以进行实时通讯的网页demo，是对WebRTC的一些学习成果。主要功能有视频通讯和文字聊天，分为客户端和信令服务器。

[源码地址](https://github.com/qianduanzhou/zhbchat)

<!--more-->

## 客户端

客户端由React框架进行编写，核心代码主要有以下两部分：

### websocket连接通讯

使用socket.io-client库与客户端的socket.io进行数据交换，实现对等连接。

```typescript
import { io, Socket } from 'socket.io-client';

let { REACT_APP_PUBLICHOST: host, REACT_APP_PUBLICPOINT: point } = process.env;
interface Option {
  onConnect?: () => void,
  onJoined?: (message: { roomId: string; userNum: number }) => void;
  onOtherJoined?: (message: { roomId: string; userId: number }) => void;
  onMessage: (data: { type: string; value: any }) => void;
  onFull?: (message: { roomId: string }) => void;
  onBye?: (message: { roomId: string; userId: number }) => void;
  onLeaved?: (message: { roomId: string }) => void;
  serverUrl?: string;
}

export default class SignalServer {
  socket!: Socket;
  roomId!: string | number;

  constructor(option: Option) {
    this.init(option);
  }

  init(option: Option) {
    this.socket = io(option.serverUrl || `http://${host}:${point}/`);
    this.socket.connect();
    this.socket.on(
      'connect', //判断socket是否已连接
      option.onConnect || (() => {
        console.log('socket connected');
      })
    )
    this.socket.on(
      'joined',
      option.onJoined ||
      (({ roomId, usersNum }) => {
        console.log('i joined a room', roomId);
        console.log('current user number:', usersNum);
      }),
    );

    this.socket.on(
      'otherjoined',
      option.onOtherJoined ||
      (({ roomId, userId }) => {
        console.log('other user joined, userId', userId);
      }),
    );

    this.socket.on('message', option.onMessage);

    this.socket.on(
      'full',
      option.onFull ||
      (({ roomId }) => {
        console.log(roomId, 'is full');
      }),
    );

    this.socket.on(
      'bye',
      option.onBye ||
      (({ roomId, userId }) => {
        console.log(userId, `leaved`, roomId);
      }),
    );

    this.socket.on('leaved', option.onLeaved || (({ roomId }) => { }));

    window.addEventListener('beforeunload', () => {
      this.leave();
    });
  }

  send(data: unknown) {
    if (!this.roomId) return;
    this.socket.emit('message', { roomId: this.roomId, data });
  }

  join(roomId: string | number) {
    this.roomId = roomId;
    this.socket.emit('join', { roomId });
  }

  leave() {
    this.roomId && this.socket.emit('leave', { roomId: this.roomId });
    this.roomId = '';
  }
}
```

### WebRTC相关内容

主要使用WebRTC相关的api，有以下几个关键的api。

- navigator.mediaDevices.getUserMedia()
- new RTCPeerConnection()
- createDataChannel()

其中**navigator.mediaDevices.getUserMedia()**获取可以打开摄像头和麦克风。**new RTCPeerConnection()**是对等连接相关，只有连接了才能进行通讯。**createDataChannel()**则是开启数据通道，在对接连接成功之后。

核心的步骤如下：

1. 初始化信令服务器

```tsx
useEffect(() => {
    // 初始化信令服务器
    signalServer.current = new SignalServer({ onMessage, onJoined, onOtherJoined, onConnect });
}, []);
```

2. 初始化本地pc对象，其中数据通道也可以在以下步骤初始化。

```tsx
// 初始化本地pc对象
  const initPeerConnection = () => {
    setConnectLoading(true);
    console.log('------ 初始化本地pc对象');
    // 创建pc实例
    peerConnection.current = new RTCPeerConnection(pcOption);
    const pc = peerConnection.current;

    // 监听 candidate 获取事件
    pc.addEventListener('icecandidate', event => {
      const candidate = event.candidate;
      if (candidate) {
        console.log('------ 获取到了本地 candidate：', candidate);

        // 发送candidate到远端
        signalServer?.current?.send({ type: 'candidate', value: candidate });
      }
    });

    // 监听到远端传过来的媒体数据
    pc.addEventListener('track', e => {
      console.log('------ 获取到了远端媒体数据：', e);
      if (remoteVideo.current && remoteVideo.current.srcObject !== e.streams[0]) {
        remoteVideo.current.srcObject = e.streams[0];
      }
    });

    // 监听对等连接状态
    pc.addEventListener('connectionstatechange', event => {
      console.log('当前对等连接状态', pc.connectionState)
      if (pc.connectionState === 'connected') {
        setState('connected');
      } else if (['disconnected', 'failed'].includes(pc.connectionState)) {
        unCall();
      }
    });

    // 创建通道
    dataChannel.current = pc.createDataChannel('sendDataChannel');

    // 监听通道
    peerConnection?.current?.addEventListener('datachannel', onGetRemoteDatachannel);

    //监听通道打开
    dataChannel.current.addEventListener('open', (e) => {
      console.log('------ 本地通道已打开：', e);
    })

    //监听通道关闭
    dataChannel.current.addEventListener('close', (e) => {
      console.log('------ 本地通道已关闭：', e);
    })
  };
```

3. 获取本地媒体数据并绑定到**pc**对象上。

```tsx
// 获取本地媒体数据
  const getLocalMediaStream = () => {
    return new Promise((resolve, reject) => {
      navigator.mediaDevices.getUserMedia({
        audio: false, video: {
          width: {
            ideal: 500
          },
          height: {
            ideal: 500
          },
        }
      }).then(mediaStream => {
        console.log('------ 成功获取本地设备媒体数据:', mediaStream);
        if (mediaStream) {
          if (localVideo.current) localVideo.current.srcObject = mediaStream;
          localMediaStream.current = mediaStream;

          // 绑定本地媒体数据到pc对象上
          if (localMediaStream.current) {
            console.log('------ 绑定本地媒体数据到pc对象上');
            localMediaStream.current.getTracks().forEach(track => {
              if (peerConnection.current) peerConnection.current.addTrack(track, localMediaStream.current as MediaStream);
            });
            resolve('addTrackDown');
          }
        }
      });
    })
  };
```

4. 建立对等连接

建立对等连接需先进行**websoket**连接，以便数据交换，在第一步初始化的时候便已建立连接，接下来则是一些逻辑判断，如同一个房间下才能进行通讯。

```tsx
 // 加入房间
  const join = () => {
    if (state !== 'disconnect') return message.error('请先启动信令服务器');
    if (!roomId) return message.error('请输入房间号');
    signalServer?.current?.join(roomId);
    setState('waiting');
  };
  // 已加入房间
  const onJoined = ({ roomId, userNum }: { roomId: string | number, userNum: string | number }) => {
    message.success('成功加入房间,当前房间人数为:' + userNum);
    console.log('------ 成功加入房间,当前房间人数为:' + userNum);

    if (userNum === 1) {
      setState('waiting');
    } else {
      setState('canCall');
    }
  };

  // 其他人加入房间
  const onOtherJoined = (data: unknown) => {
    console.log('------ 有人加入房间了');
    setState('canCall');
  };

```

接下来就是**对等连接**的建立，通过**信令服务器**（**webSocket**）交换offer和answer及candidate，并设置本地和远程描述，最后设置远端**ICE**。

```tsx
// 发起通讯
  const call = async () => {
    if (state !== 'canCall') return;
    await connectFunc();
    // 开始建立连接
    const pc = peerConnection.current;
    // 获取本地sdp(offer)
    pc?.createOffer().then(offer => {
      console.log('------ 获取到了本地offer', offer);
      // 绑定本地sdp
      pc.setLocalDescription(offer);
      // 发送本地sdp到远端
      signalServer?.current?.send({
        type: 'offer',
        value: offer,
      });
    });
  };
 // 获取远端offer
  const onGetRemoteOffer = async (offer: RTCSessionDescription) => {
    console.log('------ 获取到了远端offer', offer);
    await connectFunc();
    const pc = peerConnection.current;
    // 绑定远端sdp
    pc?.setRemoteDescription(offer);
    isSetRemoteSdpResolve('');
    // 创建本地sdp
    pc?.createAnswer().then(answer => {
      // 绑定本地sdp
      pc.setLocalDescription(answer);
      console.log('------ 获取到了本地answer', answer);
      // 发送本地sdp到远端
      signalServer?.current?.send({
        type: 'answer',
        value: answer,
      });
    });
  };
// 获取远端answer
  const onGetRemoteAnswer = (answer: RTCSessionDescription) => {
    console.log('------ 获取到了远端answer', answer);
    const pc = peerConnection.current;
    // 绑定远端sdp
    pc?.setRemoteDescription(answer);
    isSetRemoteSdpResolve('');
  };
// 获取到远端的candidate
  const onGetRemoteCandidate = async (candidate: RTCIceCandidateInit | RTCIceCandidate) => {
    await isSetRemoteSdpPromise;
    console.log('------ 获取到了远端candidate', candidate);
    peerConnection?.current?.addIceCandidate(candidate);
  };
```

5. 数据通道数据交换

**数据通道**在**对等连接**建立成功之后即可交换数据，通过**dataChannel.send()**方法进行数据交换。

```tsx
//发送消息
  const sendMsg = () => {
    if (dataChannel.current && msg) {
      setMsgList([...msgList, {
        id: msgList.length + 1,
        name: '我',
        text: msg,
        isLocal: true
      }]);
      setMsg('');
      dataChannel.current.send(msg);
    }
  }
  // 获取远端datachannel
  const onGetRemoteDatachannel = (event: RTCDataChannelEvent) => {
    const dc = event.channel;
    console.log('------ 获取到了远端通道', event.channel);
    //监听通道消息
    dc.addEventListener('message', (e: MessageEvent<any>) => {
      setMsgList(msgList => [...msgList, {
        id: msgList.length + 1,
        name: '他',
        text: e.data,
        isLocal: false
      }]);
      console.log('------ 远端通道消息：', e);
    })
    //监听通道打开
    dc.addEventListener('open', (e) => {
      console.log('------ 远端通道已打开：', e);
    })
    //监听通道关闭
    dc.addEventListener('close', (e) => {
      console.log('------ 远端通道已关闭：', e);
    })
  }
```

## 信令服务器端

**信令服务器**的作用主要是通过**websocket**进行数据交换，建立对等连接，当然也可以通过ajax请求，不过websocket更加方便一些。

由**express**和**socket.io**库实现的简单**websocket**信令服务器，具体代码如下：

```js
'use strict ';

let http = require('http'); // 提供HTTP 服务
const { Server } = require('socket.io');
let express = require('express');

const MaxUserNum = 2;

let app = express();

const roomsInfo = {};
const userRoomInfo = {};

//HTTP 服务
let http_server = http.createServer(app);
http_server.listen(8091, '0.0.0.0', () => {
  console.log('listening on *:8091');
});

const io = new Server(http_server, {
  cors: {
    origin: ['http://127.0.0.1:8090', 'http://localhost:8090', 'http://175.178.107.242:8090'],
    credentials: true,
  },
});

// 处理连接事件
io.sockets.on('connection', socket => {
  console.log('got a connection');
  // 用于转发sdp、candidate等消息
  socket.on('message', ({ roomId, data }) => {
    console.log('message , room: ' + roomId + ', data , type:' + data.type);
    socket.to(roomId).emit('message', data);
  });

  socket.on('join', ({ roomId }) => {
    if (!roomId) return;
    //加入房间
    socket.join(roomId);

    console.log(`${socket.id} join ${roomId}`);

    // 登记房间用户
    if (!roomsInfo[roomId]) {
      roomsInfo[roomId] = {};
    }
    roomsInfo[roomId][socket.id] = socket;

    //登记用户房间
    if (!userRoomInfo[socket.id]) {
      userRoomInfo[socket.id] = [];
    }
    userRoomInfo[socket.id].push(roomId);

    let userNum = Object.keys(roomsInfo[roomId]).length;

    // 如果房间里人未满
    if (userNum <= MaxUserNum) {
      // 回复用户已经加入到房间里了
      socket.emit('joined', { roomId, userNum });

      // 通知另一个用户， 有人来了
      if (userNum > 1) {
        //向roomId的所有连接用户的群发消息
        socket.to(roomId).emit('otherjoined', { roomId, userId: socket.id });
      }
    } else {
      // 如果房间里人满了，离开房间
      socket.leave(roomId);
      // 回复用户房间满人了
      socket.emit('full', { roomId, userNum });
    }
  });

  const onLeave = ({ roomId }) => {
    if (!roomId) return;

    socket.leave(roomId);

    roomsInfo[roomId] && roomsInfo[roomId][socket.id] && delete roomsInfo[roomId][socket.id];
    userRoomInfo[socket.id] &&
      (userRoomInfo[socket.id] = userRoomInfo[socket.id].filter(id => id !== roomId));

    console.log(
      'someone leaved the room, the user number of room is: ',
      roomsInfo[roomId] ? Object.keys(roomsInfo[roomId]).length : 0,
    );

    // 通知其他用户有人离开了
    socket.to(roomId).emit('bye', { roomId, userId: socket.id });

    // 回复用户你已经离开房间了
    socket.emit('leaved', { roomId });
  };

  // 用户离开房间
  socket.on('leave', onLeave);

  //disconnect
  socket.on('disconnect', () => {
    console.log(socket.id, 'disconnect, and clear user`s Room', userRoomInfo[socket.id]);
    if (userRoomInfo[socket.id]) {
      userRoomInfo[socket.id].forEach(roomId => {
        onLeave({ roomId });
      });

      delete userRoomInfo[socket.id];
    }
  });
});
```

## STUN/TRUN服务器

数据流需要内网穿透，才能进行视频和数据的通讯，不然就只能在同一个局域网进行通讯，这时候就需要用到**STUN/TRUN**服务器。

这是通过**coturn**建立的**STUN/TRUN**服务器（网上教程）：[coturn搭建**STUN/TRUN**服务器](https://www.bilibili.com/read/cv16675301)

其中需要注意，测试**STUN/TRUN**服务器的时候最好用火狐，google时不时会出错。

## 上线

通过**Jenkins**和**Docker**进行构建和部署。

## 最终效果

注意，由于WebRTC只能在本地或者https下使用，所以需要修改谷歌配置，将测试地址加入安全范围内。在谷歌地址栏中输入chrome://flags/，然后找到Insecure origins treated as secure，将其设置为Enabled，然后将地址填入下方输入框中。

{% asset_img chat.png%}